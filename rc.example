# -*- shell-script -*-

################################################################################
#-- RULES --
################################################################################

+rule --new run-page
--progs /^ls/ uname df

+rule --new run-term
--progs htop watch screen

+rule --new su-run 
--progs /^emacs /etc//

################################################################################
#-- HANDLERS -- 
################################################################################

##-- google --##################################################################

+handler --new "google"
--string '$BROWSER www.google.com/search?q=\"%1\"'
--pattern '^gg:(.+)'

##-- manual --##################################################################

+handler --new "manual"
--pattern '(.+)\?' 
--string "xterm -e 'man %1'"

################################################################################
##-- ACTIONS --
################################################################################

##-- run -- ####################################################################

+action --new 'run'
--desc 'Run command'
--type 'trap-and-launch'
--bind '\e\C-m'

action-run () 
{ 
    ! executable? && +handlers
    +rules
    return 0
}

##-- run-term -- ###############################################################

+action --new 'run-term'
--desc 'Run command in terminal'
--type 'trap-and-launch'
--bind '\et'

action-run-term () 
{ 
    ! executable? && +handlers
    +terminal
    return 0
}

+action --new 'run-page'
--desc 'Run command in terminal and page'
--type 'trap-and-launch'
--bind '\e+'

action-run-page () 
{ 
    ! executable? && +handlers
    +pager
    +terminal
    return 0
}

+action --new 'run-hold'
--desc 'Run command in terminal and hold'
--type 'trap-and-launch'
--bind '\eh'

action-run-hold () 
{ 
    ! executable? && +handlers
    command "($(command)); read -n1"
    +terminal;
    return 0
}


##-- su-run- --#################################################################

+action --new 'su-run'
--desc 'Run command as root'
--type 'trap-and-launch'
--bind '\esu'

action-su-run () 
{ 
    action-run
    +user root;
    return 0
}

##-- su-run-term --#############################################################

+action --new 'su-run-term'
--desc 'Run command in terminal as root'
--type 'trap-and-launch'
--bind '\es\C-m'

action-su-run-term () 
{ 
    action-run-term    
    +user root;
    return 0
}

##-- edit-mode-enter --###############################################################

+action --new 'edit-mode-enter'
--desc 'edit-mode-enter'
--type 'shell'
--bind '\ee'
--deps 'xdotool'
--shutdown "+action edit-mode-enter --bind '\ee'"

action-edit-mode-enter () 
{ 
    OLDPS1="$PS1";
    PS1='\[\033[1;34m\]<\[\033[1;33m\]$(objects.focus)\[\033[1;34m\]:\[\033[1;37m\] $(+$(objects.focus) --name)\[\033[1;34m\]> \[\033[0m\]';
    
    local current=$(objects.focus)
    +action edit-mode-leave --bind '\ee';
    actions.seek_start
    
    function ls () 
    { 
        $(objects.focus)s.list "$@"
    };
    complete -F objects.complete_id ls
    
    function cd ()
    {
	if [[ "$#" == "0" ]]; then
	    +action
	    return
	fi
	
	if type -t +$1 &> /dev/null; then
	    +$1
	fi
    }
    complete -F objects.complete_type cd

    cd $current

    xdotool keyup alt;
    xdotool key ctrl+m;
    return 1
}

##-- edit-mode-leave --#########################################################

+action --new 'edit-mode-leave'
--desc 'edit-mode-leave'
--deps 'xdotool'
--type 'shell'

action-edit-mode-leave () 
{ 
    PS1="$OLDPS1";
    unset -f ls;
    complete -r ls

    unset -f cd
    complete -r cd

    +action edit-mode-enter --bind '\ee';
    actions.seek_start

    xdotool keyup alt;
    xdotool key ctrl+m;
    return 1
}

##-- map/unmap/toggle --#########################################################

+action --new shell
--type shell

function action-shell {
    eval "$command"
    return 1
}

# These actions use a global variable to track the window's state
# Since this file isn't sourced every time bashrun starts, it needs to
# be initialized in the --init hook.

+action --new 'map'
--desc "map window, should work for xterm, urxvt (both set WINDOWID)"
--type "shell"
--init "BASHRUN_WINDOW_STATE=1"

function action-map {
    xdotool windowmap $WINDOWID
    BASHRUN_WINDOW_STATE=1
    return 1
}

+action --new 'unmap'
--desc "unmap window"
--type "shell" 

function action-unmap {
    xdotool windowunmap $WINDOWID
    BASHRUN_WINDOW_STATE=0
    return 1
}

+action --new 'toggle'
--desc 'toggle window state'
--type 'shell'

function action-toggle {
    if [[ BASHRUN_WINDOW_STATE -eq 1 ]]; then
	action-unmap
    else
	action-map
    fi
    return 1
}


+action --new debug
--desc "Toggle debug mode."
--type "shell"
--bind '\e[24~'

action-debug () {

    if [[ BASHRUN_DEBUG -eq 0 ]]; then
	BASHRUN_DEBUG=1
	bashrun.debug "debug mode" -g "enabled"
    else
	bashrun.debug "debug mode" -r "disabled"
	BASHRUN_DEBUG=0
    fi
    return 1
}