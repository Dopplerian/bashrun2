# -*- shell-script -*-

################################################################################

§class "§rule" "name progs" "add"

bashrun_rules_applied=0

################################################################################

function §rule.add {

    local progs="$(§rule.get_progs)"
    if [[ -z "$progs" ]]; then
	progs="$@"
    else
	progs="$progs $@"
    fi
    §rule.set_progs "$progs"
}

function §rules.apply {

    §command.get_word

    [[ bashrun_rules_applied -eq 1 ]] && return 0

    local action=$(§actions.current)
    local program=''    
    local word="$bashrun_command_word"
    local command="$bashrun_command"
    local regexp=''
    local progs=''
    local term=''

    §rules.seek_start
    while §rules.next?; do

	# eval any environment vars in progs
	progs=$(eval "echo \"$(§rule.get_progs)\"")

	for program in $progs; do

	    §terminals.seek "default"
	    
	    if [[ "$program" =~ (.+?):(.+?) ]]; then
		program="${BASH_REMATCH[1]}"
		term="${BASH_REMATCH[2]}"

		# use explicitly given terminal
		if ! §terminals.seek "$term"; then
		    §debug warn "no such terminal:" -v "$term" "(using default)"
		    §terminals.seek "default"
		fi
	    fi

	    if [[ "$word" == "$program" ]]; then
		# literal match

		# use a terminal named after program or fallback to default
		if [[ "$(§terminal.get_name)" == "default" ]]; then
		    if ! §terminals.seek "$program"; then
			§debug info "no such terminal:" -v "$program" "(using default)"
			§terminals.seek "default"
		    fi
		fi

		§debug -v "$word" "==" -v "$program" "->" -y "$(§rule.get_name)"
		bashrun_rules_applied=1

		if §actions.seek $(§rule.get_name); then
		    §action.run
		fi
		return 0
	    else
		if [[ "$program" =~ /.+?/ ]]; then
		    # regexp given
		    regexp=${program:1:${#program}-2}

		    # match the whole command against regexp
		    if [[ "$command" =~ $regexp ]]; then
			# regexp match
		
			§debug -v "'$command'" "=~" -v "$program" "->" -y "$(§rule.get_name)"
			bashrun_rules_applied=1

			if §actions.seek $(§rule.get_name); then
			    §action.run
			fi
			return 0
		    fi
		fi
	    fi
	done
	§rules.next
    done
    §rules.seek_start

    # no rule applied if we end up here
    return 1
}

function §rules.applied? {

    [[ bashrun_rules_applied -eq 1 ]] && return 0
    [[ bashrun_rules_applied -eq 0 ]] && return 1
}

function §rule.code {

    local name=$(§rule.get_name)
    local progs=$(§rule.get_progs)
    local program=''

    name=${name//\'/\\\'}
    progs=${progs//\'/\\\'}

    echo "+rule '$name'"
    echo "  --add '$progs'"
}
