# -*- shell-script -*-

################################################################################

class "rule" "name progs" ""

BASHRUN_RULES_APPLIED=0

################################################################################

function rules.apply {

    bashrun.command.get_word

    [[ BASHRUN_RULES_APPLIED -eq 1 ]] && return 0

    local action=$(actions.current)
    local program=''
    local word="$BASHRUN_COMMAND_WORD"
    local command="$BASHRUN_COMMAND"
    local regexp=''

    rules.seek_start
    while rules.next?; do

	for program in $(rule.get_progs); do

	    terminals.seek "default"
	    
	    if [[ "$program" =~ (.+?):(.+?) ]]; then
		program="${BASH_REMATCH[1]}"
		term="${BASH_REMATCH[2]}"
		if ! terminals.seek "$term"; then
		    bashrun.debug "warning: no such terminal: $term"
		    terminals.seek "default"
		fi
	    fi

	    if [[ "$word" == "$program" ]]; then
		# literal match

		bashrun.debug "$word == $program -> $(rule.get_name)"
		BASHRUN_RULES_APPLIED=1

		if actions.seek $(rule.get_name); then
		    action.run
		fi
		return 0
	    else
		if [[ "$program" =~ /.+?/ ]]; then
		    # regexp given
		    regexp=${program:1:${#program}-2}

		    # match the whole command against regexp
		    if [[ "$command" =~ $regexp ]]; then
			# regexp match
		
			bashrun.debug "'$command' =~ $program -> $(rule.get_name)"
			BASHRUN_RULES_APPLIED=1

			if actions.seek $(rule.get_name); then
			    action.run
			fi
			return 0
		    fi
		fi
	    fi
	done
	rules.next
    done
    rules.seek_start

    # no rule applied if we end up here
    return 1
}

function rules.applied? {

    [[ BASHRUN_RULES_APPLIED -eq 1 ]] && return 0
    [[ BASHRUN_RULES_APPLIED -eq 0 ]] && return 1
}

function rule.code {

    local name=$(rule.get_name)
    local progs=$(rule.get_progs)

    name=${name//\'/\\\'}
    progs=${progs//\'/\\\'}

    echo "+rule --new '$name' --progs '$progs'" 
}
