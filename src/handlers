# -*- shell-script -*-

################################################################################

§class "§handler" "name match test string action complete fallback:b" ""

bashrun_from_cmdnfh=0
bashrun_handlers_order=""

§function.clone "§handler.new" "§handler._new"
§function.clone "§handlers.dump" "§handlers._dump"

################################################################################

function §handler.new {
    §handler._new "$1"
    
    §handler.set_match '(.+)'
    §handler.set_fallback '0'
}

function §handler.fallback? {
    [[ "$(§handler.get_fallback)" == "1" ]]
}

function §handlers.init {
    bashrun_handlers_order="$(§handlers.select fallback 0) $(§handlers.select fallback 1)"
    §handlers.install_completion
}

function §handlers.apply {
    
    # applies matching handlers to bashrun_command

    §debug "trying to match handlers..."

    local name
    local handled=0

    for name in $bashrun_handlers_order; do
	§handlers.seek "$name"

	local append=1
	local match="$(§handler.get_match)"
	local string="$(§handler.get_string)"
	local action="$(§handler.get_action)"

	local result=""

	# interpolate variables if necessary (e.g. $PAGER, $BROWSER)
	if [[ $string =~ \$[a-zA-z0-9_] ]]; then
	    result="$(§interpolate '$string')"
	    §debug -v "$string" "->" -v "$result"
	    string="$result"
	fi

	if [[ "$bashrun_command" =~ $match ]]; then	    

	    §debug -c "$name" ":"  -v "$bashrun_command" "matches" -v "$match" "->"

	    local tests="$(§handler.get_test)"
	    if [[ -n "$tests" ]]; then 
		if [[ "$tests" =~ [abcdefghkprstuwxOGLSN!] ]]; then

        	    # run tests...
		    local test=""
		    local success=0
		    local k=0
		    for(( k=0; k<${#tests}; k++ )); do
			local CHAR=${tests:$k:1}
			if [[ "$CHAR" == "!" ]]; then
			    test="!"
			    continue
			else
			    test="$test -$CHAR"
			    if eval "test $test $bashrun_command_word"; then
				§debug -c "$name" ":"  \
				    -v "test $test $bashrun_command_word" "->" -g "succeeds"
				success=1
			    else
				§debug fail -c "$name" ":" \
				    -v "test $test $bashrun_command_word" "->" -r "fails" 
				success=0
				break
			    fi			
			    test=""
			fi
		    done
		else
		    tests="${tests//!/}"
		    tests="${tests//[abcdefghkprstuwxOGLSN]/}"
		    §debug -c "$name" ":"  \
			-v "$tests" "-> no such file test(s), skipping handler"
		    success=0
		fi
		
		if [[ ! success -eq 1 ]]; then
		    §debug -c "$name" ":"  "not handled"
		    §handlers.next
		    continue
		fi
	    fi

	    # subpattern substitution

	    if [[ "$string" =~ %[0-9] ]]; then

	        # rewrite handler if subpatterns match
		[[ "$bashrun_command" =~ $match ]]

		local i=0
		for (( i=1; i<${#BASH_REMATCH[*]}; i++ )); do
		    
		    local m=${BASH_REMATCH[$i]}
		    §debug -c "$name" ":"  "subpattern match:" -v "$m" "->" -v "%$i"
		    string="${string//%$i/$m}"
		    export append=0
		done
	        # fail if unmatched $n's remain in handler string
		if [[ "$string" =~ [^\\](%[0-9]) ]]; then
		    local missing=${BASH_REMATCH[1]}
		    §debug -c "$name" ":"  -v "$string"
		    §debug fail "^ string incomplete: no content for" -v "$missing"
		    return 1
		fi
	    fi

	    if [[ append -eq 1 ]]; then
		[[ -n "$string" ]] && bashrun_command="$string $bashrun_command"
	    else
		bashrun_command="$string"
	    fi

	    [[ -n "$string" ]] && §debug -c "$name" ":"  "result:" -v "$string"
	    handled=1

	    if [[ -n "$action" ]]; then
		local saved="$(§action.get_name)"
		if §actions.seek "$action"; then
		    if §action.available?; then
			§debug -c "$name" ":"  "->" -y "$action"
			§action.run
			return 0
		    fi
		fi
	    fi
	    return 0
	fi
    done

    # run bookmark function unless already handled, or pass through
    # command to let bash complain as usual.
    if [[ handled -eq 0 ]]; then
	if §command.bookmark?; then
	    $bashrun_command
	    return 0
	else
	    local cmdnfh="$(§function.code command_not_found_handle)"
	    unset -f command_not_found_handle
	    $bashrun_command
	    eval "$cmdnfh"
	fi
    fi
    return 1
}

function §handlers.install_completion {

    local name=""
    local prefix=""
    local func=""

    §handlers.seek_start
    while §handlers.next?; do
	name="$(§handler.get_name)"
	prefix=($(§handler.get_complete))
	if [[ -n prefix ]]; then
	    if §function.defined? +handler-$name-complete; then
	    
		func='function _bashrun___NAME__ {

        		local cur prev
	        	COMPREPLY=()
	        	cur="${COMP_WORDS[COMP_CWORD]}"
		        prev="${COMP_WORDS[COMP_CWORD-1]}"
		
		        if [[ ${cur} == * ]]; then		
		           COMPREPLY=($(compgen -W "$(__COMPGEN__)" ${cur}))
		        fi
		        return 0
	         }'
		
		func=${func//__NAME__/$name}
		func=${func//__COMPGEN__/+handler-$name-complete}

		echo "$func" > $bashrun_cache_home/compfunc
		source $bashrun_cache_home/compfunc
		rm $bashrun_cache_home/compfunc		
	    
		eval "function $prefix { 
                        §engine.action run 0 \"$prefix \$@\" 
                      }"
		
		complete -F "_bashrun_$name" "$prefix"

		# add this to the remote interface, too
		§remote.interface.add "# completion for +handler $name"
		§remote.interface.add "$(§function.code +handler-$name-complete)"
		§remote.interface.add "$func"
		§remote.interface.add \
		    "function $prefix { bashrun do run \"$prefix \$@\"; }"
		§remote.interface.add "complete -F '_bashrun_$name' '$prefix'"
	    fi	
	fi
	§handlers.next
    done
}

function §handler.code {

    local name="$(§handler.get_name)"
    local match="$(§handler.get_match)"
    local test="$(§handler.get_test)"
    local string="$(§handler.get_string)"
    local action="$(§handler.get_action)"
    local complete="$(§handler.get_complete)"
    local fallback="$(§handler.get_fallback)"

    match=${match//\'/\\\'}
    string=${string//\"/\\\"}
    string=${string//\$/\\\$}

    §print_line "handler $name" "#" "80"
    echo
    echo "+handler '$name'"
    [[ "$match" != '(.+)' ]] && echo "  --match '$match'" 
    [[ -n "$test" ]] && echo "  --test '$test'" 
    [[ "$string" != '%1' ]] && echo "  --string '$string'"
    [[ -n "$complete" ]] && echo "  --complete '$complete'"
    [[ -n "$action" ]] && echo "  --action '$action'"
    [[ "$fallback" -ne 0 ]] && echo "  --fallback '$fallback'"
    echo

    if §function.defined? +handler-$name-complete; then
	§function.code +handler-$name-complete
	echo
    fi
}

function §handlers.dump {

    local file="$_OBJECTS_DATA_HOME/${1:-§handlers.dump}"
    local name=''
    §handlers._dump "$1"

    local saved="$(§handler.get_name)"

    §handlers.seek_start
    while §handlers.next?; do
	name="$(§handler.get_name)"
	if §function.defined? +handler-$name-complete; then
	    §function.code "+handler-$name-complete" >> "$file"
	fi
	§handlers.next
    done
    §handlers.seek "$saved"    
}


