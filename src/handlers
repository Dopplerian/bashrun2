# -*- shell-script -*-

################################################################################

§class "§handler" "name pattern test string action complete fallback:b" ""

BASHRUN_FROM_CMDNFH=0
BASHRUN_HANDLERS_ORDER=""

§function.clone "§handler.new" "§_handler.new"
§function.clone "§handlers.dump" "§_handlers.dump"

################################################################################

function §handler.new {
    §_handler.new "$1"
    
    §handler.set_pattern '(.+)'
    §handler.set_fallback '0'
}

function §handler.fallback? {
    [[ "$(§handler.get_fallback)" == "1" ]]
}

function §handlers.init {
    BASHRUN_HANDLERS_ORDER="$(§handlers.select fallback 0) $(§handlers.select fallback 1)"
    §handlers.install_completion
}

function §handlers.apply {
    
    # applies matching handlers to BASHRUN_COMMAND

    §debug "trying to match handlers..."

    local name
    for name in $BASHRUN_HANDLERS_ORDER; do
	§handlers.seek "$name"

	local append=1
	local pattern="$(§handler.get_pattern)"
	local string="$(§handler.get_string)"
	local action="$(§handler.get_action)"

	local result=""
	# interpolate variables if necessary (e.g. $PAGER, $BROWSER)
	if [[ $string =~ \$.[a-zA-z0-9_] ]]; then
	    result="$(§interpolate '$string')"
	    §debug -v "$string" "->" -v "$result"
	    string="$result"
	fi

	if [[ "$BASHRUN_COMMAND" =~ $pattern ]]; then	    

	    §debug -v "$BASHRUN_COMMAND" "matches" -v "$pattern" "->" -y "$name"

	    if [[ BASHRUN_FROM_CMDNFH -eq 1 ]]; then
		if §handler.last? && §handler.fallback?; then
		    §debug "skipping fallback (command_not_found_handle active)"
		    §command.get_word
		    echo "bash: $BASHRUN_COMMAND_WORD: command not found"
		    return 0
		fi		    
	    fi

	    local tests="$(§handler.get_test)"
	    if [[ -n "$tests" ]]; then 
		if [[ "$tests" =~ [abcdefghkprstuwxOGLSN!] ]]; then

        	    # run tests...
		    local test=""
		    local success=0
		    local k=0
		    for(( k=0; k<${#tests}; k++ )); do
			local CHAR=${tests:$k:1}
			if [[ "$CHAR" == "!" ]]; then
			    test="!"
			    continue
			else
			    test="$test -$CHAR"
			    test="${test/ /}"
			    if eval "test $test $BASHRUN_COMMAND_WORD"; then
				§debug -v "test $test $BASHRUN_COMMAND_WORD" "->" -g "succeeds"
				success=1
			    else
				§debug fail -v "test $test $BASHRUN_COMMAND_WORD" "->" -r "fails" 
				success=0
				break
			    fi			
			    test=""
			fi
		    done
		else
		    tests="${tests//!/}"
		    tests="${tests//[abcdefghkprstuwxOGLSN]/}"
		    §debug fail -v "$tests" "-> no such file test(s), skipping handler" -y "$name"
		    success=0
		fi
		
		if [[ ! success -eq 1 ]]; then
		    §debug "not handled"
		    §handlers.next
		    continue
		fi
	    fi

	    # subpattern substitution

	    if [[ "$string" =~ %[0-9] ]]; then

	        # rewrite handler if subpatterns match
		[[ "$BASHRUN_COMMAND" =~ $pattern ]]

		local i=0
		for (( i=1; i<${#BASH_REMATCH[*]}; i++ )); do
		    
		    local match=${BASH_REMATCH[$i]}
		    §debug "subpattern match:" -v "$match" "->" -v "%$i"
		    string="${string//%$i/$match}"
		    export append=0
		done
	        # fail if unmatched $n's remain in handler string
		if [[ "$string" =~ [^\\](%[0-9]) ]]; then
		    local missing=${BASH_REMATCH[1]}
		    §debug -c "$string"
		    §debug fail "^ string incomplete: no content for" -v "$missing"
		    return 1
		fi
	    fi

	    if [[ append -eq 1 ]]; then
		[[ -n "$string" ]] && BASHRUN_COMMAND="$string $BASHRUN_COMMAND"
	    else
		BASHRUN_COMMAND="$string"
	    fi

	    [[ -n "$string" ]] && §debug "result:" -v "$string"

	    if [[ -n "$action" ]]; then
		local saved="$(§action.get_name)"
		if §actions.seek "$action"; then
		    if §action.available?; then
			§action.run
		    fi
		fi
	    fi
	    return
	fi
    done
}

function §handlers.install_completion {

    local name=""
    local prefix=""
    local func=""

    §handlers.seek_start
    while §handlers.next?; do
	name="$(§handler.get_name)"
	prefix=($(§handler.get_complete))
	if [[ -n prefix ]]; then
	    if §function.defined? +handler-$name-complete; then
	    
		func='function _bashrun___NAME__ {

        		local cur prev
	        	COMPREPLY=()
	        	cur="${COMP_WORDS[COMP_CWORD]}"
		        prev="${COMP_WORDS[COMP_CWORD-1]}"
		
		        if [[ ${cur} == * ]]; then		
		           COMPREPLY=($(compgen -W "$(__COMPGEN__)" ${cur}))
		        fi
		        return 0
	         }'
		
		func=${func//__NAME__/$name}
		func=${func//__COMPGEN__/+handler-$name-complete}

		echo "$func" > $BASHRUN_CACHE_HOME/compfunc
		source $BASHRUN_CACHE_HOME/compfunc
		rm $BASHRUN_CACHE_HOME/compfunc		
	    
		eval "function $prefix { 
                        §engine.action run 0 \"$prefix \$@\" 
                      }"
		
		complete -F "_bashrun_$name" "$prefix"
	    fi	
	fi
	§handlers.next
    done
}

function §handler.code {

    local name="$(§handler.get_name)"
    local pattern="$(§handler.get_pattern)"
    local test="$(§handler.get_test)"
    local string="$(§handler.get_string)"
    local action="$(§handler.get_action)"
    local complete="$(§handler.get_complete)"
    local fallback="$(§handler.get_fallback)"

    pattern=${pattern//\'/\\\'}
    string=${string//\"/\\\"}
    string=${string//\$/\\\$}

    §print_line "handler $name" "#" "80"
    echo
    echo "+handler '$name'"
    [[ "$pattern" != '(.+)' ]] && echo "  --pattern '$pattern'" 
    [[ -n "$test" ]] && echo "  --test '$test'" 
    [[ "$string" != '%1' ]] && echo "  --string '$string'"
    [[ -n "$complete" ]] && echo "  --complete '$complete'"
    [[ -n "$action" ]] && echo "  --action '$action'"
    [[ "$fallback" -ne 0 ]] && echo "  --fallback '$fallback'"
    echo

    if §function.defined? +handler-$name-complete; then
	§function.code +handler-$name-complete
	echo
    fi
}

function §handlers.dump {

    local file="$_OBJECTS_DATA_HOME/${1:-§handlers.dump}"
    local name=''
    §_handlers.dump "$1"

    local saved="$(§handler.get_name)"

    §handlers.seek_start
    while §handlers.next?; do
	name="$(§handler.get_name)"
	if §function.defined? +handler-$name-complete; then
	    §function.code "+handler-$name-complete" >> "$file"
	fi
	§handlers.next
    done
    §handlers.seek "$saved"    
}


