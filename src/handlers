# -*- shell-script -*-

################################################################################

§class "§handler" "name pattern string action complete fallback:b" ""

BASHRUN_FROM_CMDNFH=0

################################################################################

§function.clone §handler.new §_handler.new

function §handler.new {
    §_handler.new "$1"
    
    §handler.set_pattern '(.+)'
    §handler.set_string '%1'
    §handler.set_fallback '0'
}

function §handler.fallback? {
    [[ "$(§handler.get_fallback)" == "1" ]]
}

function §handlers.install_completion {

    local name=""
    local prefix=""
    local func=""

    §handlers.seek_start
    while §handlers.next?; do
	name="$(§handler.get_name)"
	prefix=($(§handler.get_complete))
	if [[ -n prefix ]]; then
	    if §function.defined? +handler-$name-complete; then
	    
		func='function _bashrun___NAME__ {

        		local cur prev
	        	COMPREPLY=()
	        	cur="${COMP_WORDS[COMP_CWORD]}"
		        prev="${COMP_WORDS[COMP_CWORD-1]}"
		
		        if [[ ${cur} == * ]]; then		
		           COMPREPLY=($(compgen -W "$(__COMPGEN__)" ${cur}))
		        fi
		        return 0
	         }'
		
		func=${func//__NAME__/$name}
		func=${func//__COMPGEN__/+handler-$name-complete}

		echo "$func" > $BASHRUN_CACHE_HOME/compfunc
		source $BASHRUN_CACHE_HOME/compfunc
		rm $BASHRUN_CACHE_HOME/compfunc		
	    
		eval "function $prefix { 
                        §engine.action run 0 \"$prefix \$@\" 
                      }"
		
		complete -F "_bashrun_$name" "$prefix"
	    fi	
	fi
	§handlers.next
    done
}

function §handlers.apply {
    
    # applies matching handlers to BASHRUN_BASHRUN_COMMAND

    §debug "trying to match handlers..."
    
    §handlers.seek_start
    while §handlers.next?; do
	
	local append=1
	local name="$(§handler.get_name)"
	local pattern="$(§handler.get_pattern)"
	local string="$(§handler.get_string)"
	local action="$(§handler.get_action)"

	# eval if this contains vars (e.g. $PAGER, $BROWSER)
	if [[ $string =~ \$.[a-zA-z0-9_] ]]; then
	    §debug -c "evaling handler string..."
	    eval "string=\"$string\""
	fi

	if [[ "$BASHRUN_COMMAND" =~ $pattern ]]; then	    

	    §debug -v "$BASHRUN_COMMAND" "matches" -v "$pattern" -y "$name"

	    if [[ BASHRUN_FROM_CMDNFH -eq 1 ]]; then
		if §handler.last? && §handler.fallback?; then
		    §debug "skipping fallback (command_not_found_handle active)"
		    §command.get_word
		    echo "bash: $BASHRUN_COMMAND_WORD: command not found"
		    return 0
		fi		    
	    fi

	    # check for file test prefix
	    if [[ "$string" =~ ^([abcdefghkprstuwxOGLSN!]+): ]]; then
		local tests="${BASH_REMATCH[1]}"
		string="${string/$tests:/}"

		# perform tests
		local test=""
		local success=0
		local k=0
		for(( k=0; k<${#tests}; k++ )); do
		    local CHAR=${tests:$k:1}
		    if [[ "$CHAR" == "!" ]]; then
			test="!"
			continue
		    else
			test="$test -$CHAR"
			if eval "test $test $BASHRUN_COMMAND_WORD"; then
			    §debug "test $test $BASHRUN_COMMAND_WORD -> success"
			    success=1
			else
			    §debug "test $test $BASHRUN_COMMAND_WORD -> FAIL"
			    success=0
			    break
			fi			
			test=""
		    fi
		done
		if [[ ! success -eq 1 ]]; then
		    §debug "not handled"
		    §handlers.next
		    continue
		fi
	    fi

	    if [[ "$string" =~ %[0-9] ]]; then

	        # rewrite handler if subpatterns match
		[[ "$BASHRUN_COMMAND" =~ $pattern ]]

		local i=0
		for (( i=1; i<${#BASH_REMATCH[*]}; i++ )); do
		    
		    local match=${BASH_REMATCH[$i]}
		    §debug "subexpression match \%$i $match"
		    string="${string//%$i/$match}"
		    
		    §debug "$string"
		    export append=0
		done
	        # fail if unmatched $n's remain in handler string
		if [[ "$string" =~ (%[0-9]) ]]; then
		    local missing=${BASH_REMATCH[1]}
		    §debug "handler incomplete: no content for $missing"
		    §debug " -> not executing"
		    return 1
		fi
	    fi

	    if [[ append -eq 1 ]]; then
		BASHRUN_COMMAND="$string $BASHRUN_COMMAND"
	    else
		BASHRUN_COMMAND="$string"
	    fi

	    if [[ -n "$action" ]]; then
		local saved="$(§action.get_name)"
		if §actions.seek "$action"; then
		    if §action.available?; then
			§action.run
		    fi
		fi
	    fi

	    §debug "$string"
	    return
	fi
	§handlers.next
    done
}

function §handler.code {

    local name=$(§handler.get_name)
    local pattern=$(§handler.get_pattern)
    local string=$(§handler.get_string)
    local action=$(§handler.get_action)
    local complete=$(§handler.get_complete)
    local fallback=$(§handler.get_fallback)

    name=${name//\'/\\\'}
    pattern=${pattern//\'/\\\'}
    string=${string//\"/\\\"}
    string=${string//\$/\\\$}

    §print_line "handler $name" "#" "80"
    echo
    echo "+handler '$name'"
    [[ "$pattern" != '(.+)' ]] && echo "  --pattern '$pattern'" 
    [[ "$string" != '%1' ]] && echo "  --string '$string'"
    [[ -n "$complete" ]] && echo "  --complete '$complete'"
    [[ -n "$action" ]] && echo "  --action '$action'"
    [[ "$fallback" -ne 0 ]] && echo "  --fallback '$fallback'"
    echo

    if §function.defined? +handler-$name-complete; then
	§function.code +handler-$name-complete
	echo
    fi
}

§function.clone "§handlers.dump" "§_handlers.dump"

function §handlers.dump {

    local file="$_OBJECTS_DATA_HOME/${1:-§handlers.dump}"
    local name=''
    §_handlers.dump "$1"

    local saved="$(§handler.get_name)"

    §handlers.seek_start
    while §handlers.next?; do
	name="$(§handler.get_name)"
	if §function.defined? +handler-$name-complete; then
	    §function.code "+handler-$name-complete" >> "$file"
	fi
	§handlers.next
    done
    §handlers.seek "$saved"    
}


