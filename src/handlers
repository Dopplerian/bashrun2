# -*- shell-script -*-

################################################################################

class "handler" "name pattern string" ""

################################################################################

function handlers.add {

    if handlers.seek $1; then
	[[ $2 != '' ]] && handler.set_pattern "$2"
    else
	handler.new "$1" "$2" "$3"
    fi
}

function handlers.apply {
    
    # applies matching handlers to BASHRUN_BASHRUN_COMMAND

    bashrun.debug "trying to match handlers..."
    
    handlers.seek_start
    while handlers.next?; do
	
	local append=1
	local pattern=$(handler.get_pattern)
	local string=$(handler.get_string)

	if [[ "$BASHRUN_COMMAND" =~ $pattern ]]; then	    

	    bashrun.debug "$BASHRUN_COMMAND matches $pattern"

	    # check for file test prefix
	    if [[ "$string" =~ ^([abcdefghkprstuwxOGLSN!]+): ]]; then
		local tests=${BASH_REMATCH[1]}
		string=${string/$tests:/}

		# perform tests
		local test=""
		local success=0
		local k=0
		for(( k=0; k<${#tests}; k++ )); do
		    local CHAR=${tests:$k:1}
		    if [[ "$CHAR" == "!" ]]; then
			test="!"
			continue
		    else
			test="$test -$CHAR"
			if eval "test $test $BASHRUN_COMMAND_WORD"; then
			    bashrun.debug "test $test $BASHRUN_COMMAND_WORD -> success"
			    success=1
			else
			    bashrun.debug "test $test $BASHRUN_COMMAND_WORD -> FAIL"
			    success=0
			    break
			fi			
			test=""
		    fi
		done
		if [[ ! success -eq 1 ]]; then
		    bashrun.debug "not handled"
		    continue
		fi
	    fi

	    if [[ "$string" =~ %[0-9] ]]; then

	        # rewrite handler if subpatterns match
		[[ "$BASHRUN_COMMAND" =~ $pattern ]]

		local i=0
		for (( i=1; i<${#BASH_REMATCH[*]}; i++ )); do
		    
		    local match=${BASH_REMATCH[$i]}
		    bashrun.debug "subexpression match \%$i $match"
		    string=${string//%$i/$match}
		    
		    bashrun.debug "$string"
		    export append=0
		done
	        # fail if unmatched $n's remain in handler string
		if [[ "$string" =~ (%[0-9]) ]]; then
		    local missing=${BASH_REMATCH[1]}
		    bashrun.debug "handler incomplete: no content for $missing"
		    bashrun.debug " -> not executing, informing user"
		    BASHRUN_COMMAND="bashrun_show_error No content for \\$missing in $pattern handler."
		    return 1
		fi
	    fi

	    # eval if this contains vars (e.g. $PAGER, $BROWSER)
	    if [[ $string =~ \$.[a-zA-z0-9_] ]]; then
		eval "string=\"$string\""
	    fi

	    if [[ append -eq 1 ]]; then
		BASHRUN_COMMAND="$string $BASHRUN_COMMAND"
	    else
		BASHRUN_COMMAND="$string"
	    fi
	    bashrun.debug "$string"
	    return
	fi
	handlers.next
    done
}

function handler.code {

    local name=$(handler.get_name)
    local pattern=$(handler.get_pattern)
    local string=$(handler.get_string)

    name=${name//\'/\\\'}
    pattern=${pattern//\'/\\\'}
    string=${string//\"/\\\"}
    string=${string//\$/\\\$}

    print_line "handler $name" "#" "80"
    echo
    echo "+handler --new '$name'"
    echo "--pattern '$pattern'" 
    echo "--string \"$string\""
    echo
}

