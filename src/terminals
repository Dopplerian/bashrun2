# -*- shell-script -*-

################################################################################

§class "terminal" --with-interface \
    --properties "name" \
                 "command=__EXEC_TERMINAL__" \
                 "classname" \
                 "geometry=80x24" \
                 "font" \
                 "foreground" \
                 "background" \
                 "options" \
                 "match:a" \
                 "cache:t"

§class "template" --with-interface \
    --properties "name" \
                 "classname=-name %n" \
                 "geometry=-g %g" \
                 "font=-fn %f" \
                 "foreground=-fg %t" \
                 "background=-bg %b" \
                 "bashrun=-e %*" \
                 "bashrun_options=+sb" \
                 "execute=-e bash -c %@"

################################################################################

§function.clone "§terminal.set_match" "§terminal._set_match"
§function.clone "§terminals.init" "§terminals._init"
§function.clone "§terminal.get_command" "§terminal._get_command"

function §terminal.set_match {

    eval "$(§terminal.get_match matches)"

    if (( ${#matches[*]} == 0 )); then
	matches=("$@")
    else
	matches=("${matches[@]}" "$@")
    fi
    §terminal._set_match "${matches[@]}"
}

function §terminals.init {
    bashrun_terminals_used="$(§terminals.used)"
    §terminals._init
}

function §terminal.init {
   §terminal.set_cache ""
   §terminal.get_command &>/dev/null
}

function §terminal.get_command {
    
    local command="$(§terminal._get_command)"
    local cached="$(§terminal.get_cache)"

    if [[ -z "$cached" ]]; then
	local classname="$(§terminal.get_classname)"
	local geometry="$(§terminal.get_geometry)"
	local font="$(§terminal.get_font)"
	local foreground="$(§terminal.get_foreground)"
	local background="$(§terminal.get_background)"
	local options="$(§terminal.get_options)"
	
	cached="$(§terminal.expand "$command" "" "$classname" "$geometry" "$font" "$foreground" "$background" "$options")"
	§terminal.set_cache "$cached"	
    fi
    printf '%s' "$cached"
}

function §terminal.expand {
    local template="$1"
    local command="$2"
    local classname="$3"
    local geometry="$4"
    local font="$5"
    local foreground="$6"
    local background="$7"
    local options="$8"
    
    local word="" tmp="" method=""
    declare -i i=0

    local type="execute"
    if [[ -n "$command" ]]; then
	type="bashrun"
    fi

    if §templates.seek "$template"; then
	template="$(§template.create_commandline \
                    "execute" "$classname" "$geometry" \
                    "$font" "$foreground" "$background" "$options")"
    fi

    # insert classname, geometry, font and options
    if [[ "$template" =~ [^\\]%n ]]; then
	template="$(§replace "$template" "%n" "$classname")"
    fi

    if [[ "$template" =~ [^\\]%g ]]; then
	template="$(§replace "$template" "%g" "$geometry")"
    fi

    if [[ "$template" =~ [^\\]%f ]]; then
	§quote font
	template="$(§replace "$template" "%f" "$font")"
    fi

    if [[ "$template" =~ [^\\]%t ]]; then
	§quote foreground
	template="$(§replace "$template" "%t" "$foreground")"
    fi

    if [[ "$template" =~ [^\\]%b ]]; then
	§quote background
	template="$(§replace "$template" "%b" "$background")"
    fi

    if [[ "$template" =~ [^\\]%o ]]; then
	template="$(§replace "$template" "%o" "$options")"
    fi

    # insert command if given...

    # %* insert command split into words
    # %@ insert command as a single word (one level of quoting)
    # %@@, %@@@, ... add two, three, etc. levels of quoting
    if [[ -n "$command" ]]; then
	if [[ "$template" =~ [^\\]%((@|\*)+) ]]; then
	    method="${BASH_REMATCH[1]}"
	    
	    if [[ "$method" =~ @ ]]; then
		§quote ${#method} command
	    fi
	    
	    # insert command into template
	    template="$(§replace "$template" "%$method" "$command")"
	    
	else
	# append unquoted command to template
	    template+=" $command"
	fi
    fi

    printf '%s' "$template"
}

function §terminal.binary {
    local binary=""
    for binary in $(§terminal.get_command); do break; done
    printf '%s' "$binary"
}

function §terminal.list {
    local opt="$1"

    if [[ "$opt" == "-l" ]]; then
	local key
	for key in ${_bashrun_terminals_keys[@]}; do
	    if [[ "$key" == "command" ]]; then
		printf '%s\n' "$key: $(§terminal._get_command)"
	    else
		printf '%s\n' "$key: $(§terminal.get $key)"
	    fi
	done;
	printf '\n'
    else
	printf '%s\n' "$(§terminal.id)"
    fi
}

function §terminals.used {
    local used=""
    local saved="$(§terminal.get_name)"
    local binary=""

    §terminals.seek_start
    while §terminals.next?; do
	
	binary="$(§terminal.binary)"	
	if [[ ! " $used " =~ $binary ]]; then
	    used="$binary $used"
	fi
	§terminals.next
    done
    §terminals.seek "$saved"
    
    printf '%s' "$used"
}

function §terminals.get_match {
    local saved="$(§terminal.get_name)"
    local match=()
    local data=""

    §terminals.seek_start
    while §terminals.next?; do
        eval "$(§terminal.get_match m)"
	match=( "${match[@]}" "${m[@]}" )
	§terminals.next
    done

    §terminals.seek "$saved"

    local data="$(declare -p match)"
    data="${data:18:${#data}-19}"    
    data="declare -a $1=$data"
    printf '%s' "$data"
}
