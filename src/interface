# -*- shell-script -*-

################################################################################
#
# User interface functions
#
# These function provide a commandline interface to creating and
# changing actions and binding them.
#
# §action
# §name
# §type
# §desc
# §add
# §bind
# §unbind
# §rebind
# §code
# §ls
#
################################################################################

function §action {
    actions.add "$1" "$2" "$3" "$4"

    if [[ "$1" == '' ]]; then
	echo "error: missing action argument"
	return 1
    fi

    if ! action.function?; then
	eval "function action-$1 { :; }"
    fi
    return 0
}

function §name {

    local action=$1
    if actions.seek $action; then
	shift
    else
	action=$(action.name)
    fi
    echo $(action.name)
}

function §desc {

    local num_args=$#
    local action=$1
    local value=''

    if actions.seek $action; then
	shift
	(( num_args-=1 ))
    else
	action=$(action.name)
    fi
    value=$1

    if actions.seek $action; then
	if [[ "$num_args" == "1" ]]; then
	    action.set_desc "$value"
	else
	    echo "$(action.desc)"
	fi
    else
	echo "error: no such action: $action"
	return 1
    fi
    return 0	
}

function §type {

    local num_args=$#
    local action=$1
    local value=''

    if actions.seek $action; then
	shift
	(( num_args-=1 ))
    else
	action=$(action.name)
    fi
    value=$1

    if actions.seek $action; then
	if [[ "$num_args" == "1" ]]; then
	    action.set_type "$value"
	else
	    echo "$(action.type)"
	fi
    else
	echo "error: no such action: $action"
	return 1
    fi
    return 0	
}

function §help {

    local numargs=$#
    local action=$1
    local help=$2

    if [[ "$action" == '' ]]; then
	actions.help
	return 0
    fi

    if actions.seek $action; then
	if [[ "$numargs" == "2" ]]; then
	    action.set_help "$help"
	else
	    §ls $action
	fi
    else
	echo "error: no such action: $action"
	return 1
    fi
    return 0	
}

function §bind {

    local action=$1
    local keyseq=$2
    local keymap=$3
    local keyname=$4

    if [[ "$keyseq" == '' ]]; then
	echo "error: missing keyseq argument"
	return 1
    fi

    if actions.seek $action; then
	action.bind $keyseq $keymap "$keyname"
	return $?
    else
	echo "error: no such action: $action"
	return 1
    fi
}

function §unbind {

    local action=$1
    local keymap=$2
    local keyseq=$3
    if actions.seek $action; then
	action.unbind "$keymap" "$keyseq"
	return $?
    else
	echo "error: no such action: $action"
	return 1
    fi
}

function §rebind {

    local action=$1
    local keymap=$2

    if actions.seek $action; then
	action.rebind $keymap
	return $?
    else
	echo "error: no such action: $action"
	return 1
    fi
}

function §code {

    if [[ $# -gt 0 ]]; then
	if ! actions.seek $1; then
	    [[ "$1" == "--handlers" || "$1" == "--all" ]] && handlers.code
	    [[ "$1" == "--bookmarks" || "$1" == "--all" ]] && bookmarks_code
	    [[ "$1" == "--actions" || "$1" == "--all" ]] && actions.code
	    return
	fi

	local id
	for id in $@; do
	    if actions.seek $id; then
		action.code
	    fi
	done
    else
	# default
	§code --all
    fi
}

function §ls {

    if [[ $# -gt 0 ]]; then
	if [[ "$1" == "--all" ]]; then
	    actions.pretty_print
	    return
	fi

	local id
	for id in $@; do
	    if actions.seek $id; then
		action.pretty_print
	    fi
	done
    else
	actions.pretty_print
    fi
}

function §handler {
    handler.new "$1" "$2"
}

function §bookmark {
    bookmark_new "$1"
}

function bashrun_action.interface_enable {

    function §command {
	if [[ "$#" == "0" ]]; then
	    echo $BASHRUN_COMMAND
	else
	    BASHRUN_COMMAND="$@"
	    bashrun_log "$BASHRUN_COMMAND"
	fi
    }

    function §line { echo $BASHRUN_COMMAND_LINE; }

    function §is_executable {
	bashrun_command_word_is_executable?
	return $?
    }

    function §is_builtin {
	bashrun_command_word_is_builtin?
	return $?
    }

    function §is_bookmark {
	bashrun_command_word_is_bookmark?
    }
    
    function §handlers { handlers.apply; }
    function §rules { :; }
    function §terminal { bashrun_command_wrap_in_terminal; }
    function §user { bashrun_command_wrap_in_su ${1:-root}; }
}

function bashrun_action.interface_disable {

        unset -f \
	    §command \
	    §line \
	    §is_executable \
	    §is_builtin \
	    §is_bookmark \
	    §handlers \
	    §rules \
	    §terminal \
	    §help \
	    §user
}

# completion

_bashrun_actions() 
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="$(actions.names)"

    if [[ ${cur} == * ]]; then
	if [[ ${prev} =~ ^§ ]] ; then
            COMPREPLY=( $(compgen -W "${opts}" ${cur}) )
	else
	    COMPREPLY=()	    
	fi
        return 0
    fi
}

complete -o default -F _bashrun_actions \
    §action \
    §name \
    §type \
    §desc \
    §bind \
    §unbind \
    §rebind \
    §code \
    §ls

################################################################################
