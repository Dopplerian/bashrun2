# -*- shell-script -*-

BASHRUN_WINDOW_ID=""
BASHRUN_WINDOW_POS_X=0
BASHRUN_WINDOW_POS_Y=0
BASHRUN_WINDOW_WIDTH=$COLUMNS
BASHRUN_WINDOW_HEIGHT=$LINES
BASHRUN_WINDOW_PIXEL_WIDTH=$COLUMNS
BASHRUN_WINDOW_PIXEL_HEIGHT=$LINES
BASHRUN_WINDOW_MAPPED=1
BASHRUN_WINDOW_ANIMATE=0
BASHRUN_WINDOW_HINT=0
BASHRUN_WINDOW_HINT_X=0
BASHRUN_WINDOW_HINT_Y=0

BASHRUN_RESET_TERM="$BASHRUN_CACHE_HOME/${BASHRUN_MODE:-terminal}-reset"

function §window? {
    [[ -n "$BASHRUN_WINDOW_ID" ]]
}

function §window.exists? () {
    xwininfo -id "$1" &>/dev/null
}

function §window.mapped? {
    §window? || return 1
    [[ BASHRUN_WINDOW_MAPPED -eq 1 ]]
}

function §window.unmapped? {
    §window? || return 1
    [[ BASHRUN_WINDOW_MAPPED -eq 0 ]]
}

function §window.wait {

    local state="${1:-unmap}"
    local name="bashrun-$BASHRUN_MODE"

    if [[ "$state" == "map" ]]; then
	while sleep 0.1; do
	    if [[ ! "$(xdotool search --onlyvisible --name $name 2> /dev/null)" == '' ]]; then
		break
	    fi
	done

    elif [[ "$state" == "unmap" ]]; then
	while sleep 0.1; do
	    if [[ "$(xdotool search --onlyvisible --name $name 2> /dev/null)" == '' ]]; then
		break
	    fi
	done
    fi
}

function §window.terminal? {
    §window? || return 1
    [[ "$BASHRUN_WINDOW_ID" == "$WINDOWID" ]]
}

function §window.animate? {
     §window? || return 1
     [[ BASHRUN_WINDOW_ANIMATE -eq 1 ]]
}
function §window.animate {
    BASHRUN_WINDOW_ANIMATE=${1:-1}
}

function §window.hint? {
    [[ BASHRUN_WINDOW_HINT -eq 1 ]]
}

function §window.id {
    
    if [[ $# -eq 0 ]]; then
	echo $BASHRUN_WINDOW_ID
    elif [[ $# -eq 1 ]]; then
	BASHRUN_WINDOW_ID=$1	    
	§window.update
    else
	BASHRUN_WINDOW_ID=$1	    
	§window.update 1
    fi
    return 0
}

function §window.update {

    if [[ $# -eq 1 ]]; then
	# fast update, mapping state only
	if [[ "$(xwininfo -id $BASHRUN_WINDOW_ID)" =~ "IsViewable" ]]; then
	    BASHRUN_WINDOW_MAPPED=1
	else
	    BASHRUN_WINDOW_MAPPED=0
	fi
	return 0
    fi

    # complete update...

    local saved="$IFS"
    local line=''
    local x y w h pw ph

    IFS=$'\n'
    for line in $(xwininfo -all -id $BASHRUN_WINDOW_ID); do

	if [[ "$line" =~ "Width: "([0-9]+) ]]; then
	    (( pw+=${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Height: "([0-9]+) ]]; then
	    (( ph+=${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Relative upper-left X:  "([0-9]+) ]]; then
	    (( x -= ${BASH_REMATCH[1]} ))
	    (( pw = ${BASH_REMATCH[1]} * 2 )) # assume uniform border width
	fi

	if [[ "$line" =~ "Absolute upper-left Y:  "([0-9]+) ]]; then
	    (( y = ${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Relative upper-left Y:  "([0-9]+) ]]; then
	    (( y -= ${BASH_REMATCH[1]} ))
	    (( ph = ${BASH_REMATCH[1]} * 2 )) # assume uniform border width
	fi

	if [[ "$line" =~ "-geometry "([0-9]+)x([0-9]+) ]]; then
	    w=${BASH_REMATCH[1]}
	    h=${BASH_REMATCH[2]}
	fi

	if [[ "$line" =~ "Map State: "(.+) ]]; then
	    [[ ${BASH_REMATCH[1]} == 'IsUnMapped' ]] && BASHRUN_WINDOW_MAPPED=0
	    [[ ${BASH_REMATCH[1]} == 'IsViewable' ]] && BASHRUN_WINDOW_MAPPED=1
	fi

	if [[ "$line" =~ ([xy])\ resize\ increment:\ ([0-9]+) ]]; then
	    BASHRUN_WINDOW_HINT=1
	    if [[ "${BASH_REMATCH[1]}" == "x" ]]; then
		BASHRUN_WINDOW_HINT_X="${BASH_REMATCH[2]}"
		
	    elif [[ "${BASH_REMATCH[1]}" == "y" ]]; then
		BASHRUN_WINDOW_HINT_Y="${BASH_REMATCH[2]}"
	    fi
	fi
    done
    IFS="$saved"

    BASHRUN_WINDOW_POS_X=$x
    BASHRUN_WINDOW_POS_Y=$y
    BASHRUN_WINDOW_WIDTH=$w
    BASHRUN_WINDOW_HEIGHT=$h
    BASHRUN_WINDOW_PIXEL_WIDTH=$pw
    BASHRUN_WINDOW_PIXEL_HEIGHT=$ph
    BASHRUN_WINDOW_ANIMATE="$(§mode.get_animated)"
}

function §window.geometry {

    §window.update
    if [[ "$(§geometry)" != "$1" ]]; then
	§geometry.parse "$1"
	§debug "Setting geometry" -v  "$1" 

	if §geometry.size?; then
	    §window.size --hint $(§geometry.width) $(§geometry.height)
	fi

	if §geometry.position?; then
	    §window.pos $(§geometry.x $BASHRUN_WINDOW_PIXEL_WIDTH) \
		$(§geometry.y $BASHRUN_WINDOW_PIXEL_HEIGHT)	
	fi
    fi
}

function §window.pos {
    
    if [[ $# -eq 0 ]]; then
	§window.update
	echo $BASHRUN_WINDOW_POS_X $BASHRUN_WINDOW_POS_Y
    else
	§window? || return 1
	
	local x="$1"
	local y="$2"
	
	if [[ "$x" =~ ([0-9]+)x([0-9]+) ]]; then
	    x=${BASH_REMATCH[1]}
	    y=${BASH_REMATCH[2]}
	fi
	
	§xdotool windowmove $BASHRUN_WINDOW_ID $x $y 
	BASHRUN_WINDOW_POS_X=$x
	BASHRUN_WINDOW_POS_Y=$y
    fi
    return 0
}

function §window.resize {
    case $1 in
	up)
            (( BASHRUN_WINDOW_HEIGHT-=1 ))
	    ;;
	down)
            (( BASHRUN_WINDOW_HEIGHT+=1 ))
	    ;;
	left)
            (( BASHRUN_WINDOW_WIDTH-=1 ))
	    ;;
	right)
            (( BASHRUN_WINDOW_WIDTH+=1 ))
	    ;;
    esac
    [[ BASHRUN_WINDOW_HEIGHT -lt 1 ]] && BASHRUN_WINDOW_HEIGHT=1
    [[ BASHRUN_WINDOW_WIDTH -lt 1 ]] && BASHRUN_WINDOW_WIDTH=1
    §window.size --hint $BASHRUN_WINDOW_WIDTH $BASHRUN_WINDOW_HEIGHT
}

function §window.size {
    
    # get window size
    if [[ $# -eq 0 ]]; then
	§window.update
	echo $BASHRUN_WINDOW_WIDTH $BASHRUN_WINDOW_HEIGHT
	return 0;
    fi

    §window? || return 1

    # resize from the outside using §xdotool (using xterms/urxvt's
    # escape sequences is unreliable, causing random freezes)

    local hint=""
    if [[ "$1" == "--hint" ]]; then
	hint="--usehints"
	shift
    fi

    if [[ $# -eq 1 ]]; then
	if [[ "$width" =~ ([0-9]+)x([0-9]+) ]]; then
	    local w=${BASH_REMATCH[1]}
	    local h=${BASH_REMATCH[2]}
	    §xdotool windowsize $hint $BASHRUN_WINDOW_ID $w $h
	    BASHRUN_WINDOW_WIDTH=$w
	    BASHRUN_WINDOW_HEIGHT=$h
	fi
    fi

    if [[ $# -eq 2 ]]; then
	§xdotool windowsize $hint $BASHRUN_WINDOW_ID $1 $2
	BASHRUN_WINDOW_WIDTH=$1
	BASHRUN_WINDOW_HEIGHT=$2
    fi 
        
    # apply completion threshold if necessary
    §window.terminal? && §completion.set $(§mode.get_completion)
    return 0
}
 
function §window.map {

    §window? || return 1
    [[ $# -eq 0 ]] && §window.update
    
    # parse geometry for this mode 
    §geometry.parse "$(§mode.get_geometry 0)"

    # map the window
    §xdotool windowmap $BASHRUN_WINDOW_ID
    
    # apply position
    if §geometry.position?; then
	§window.pos "$(§geometry.x)" "$(§geometry.y)"
    fi

    # move to the current desktop if required
    if [[ "$(§xdotool get_desktop_for_window $BASHRUN_WINDOW_ID)" != "-1" ]]; then
	§xdotool set_desktop_for_window $BASHRUN_WINDOW_ID $(§xdotool get_desktop)
    fi

    # focus
    §xdotool windowactivate $BASHRUN_WINDOW_ID
    §xdotool windowfocus $BASHRUN_WINDOW_ID	

    # reset term if neccessary (previous remote su invocation)
    if [[ -f "$BASHRUN_RESET_TERM" ]]; then
	§xdotool key --clearmodifiers Return
    fi

    # call user supplied onmap handler
    $(§mode.get_onmap)
    
    if [[ BASHRUN_WINDOW_ANIMATE -eq 1 ]]; then
	§window.expand
    fi    
    BASHRUN_WINDOW_MAPPED=1
    return 0
}

function §window.unmap {

    §window? || return 1
    [[ $# -eq 0 ]] && §window.update

    if [[ BASHRUN_WINDOW_ANIMATE -eq 1 ]]; then
	§window.collapse
    fi
    §xdotool windowunmap $BASHRUN_WINDOW_ID

    # call user supplied onunmap handler    
    $(§mode.get_onunmap)

    BASHRUN_WINDOW_MAPPED=0
    return 0
}

function §window.toggle { # [smart] [fast]
    
    local smart=$1
    local fast=$2

    §window? || return 1
    §window.update $fast

    if [[ BASHRUN_WINDOW_MAPPED -eq 0 ]]; then	
	§window.map
    else
	if [[ smart -eq 1 ]]; then
	    if [[ "$(§xdotool getwindowfocus)" != "$BASHRUN_WINDOW_ID" ]]; then
		§window.map $fast
	    else
		§window.unmap $fast
	    fi
	else
	    §window.unmap $fast
	fi
    fi
    return 0
}

function §window.toggle_smart {
    §window.toggle 1 $1
}

function §window.collapse {

    local i=0
    for (( i=$BASHRUN_WINDOW_HEIGHT; i>1; i-- )); do
	(( BASHRUN_WINDOW_HEIGHT-=1 ))
	§xdotool windowsize --usehints $BASHRUN_WINDOW_ID \
	    $BASHRUN_WINDOW_WIDTH \
	    $BASHRUN_WINDOW_HEIGHT
    done
}

function §window.expand {

    local max_height="$(§geometry.height)"

    [[ BASHRUN_WINDOW_HEIGHT -ge max_height ]] && return 1

    local i=0
    for (( i=1; i<=max_height-1; i++ )); do
	(( BASHRUN_WINDOW_HEIGHT+=1 ))
	§xdotool windowsize --usehints $BASHRUN_WINDOW_ID \
	    $BASHRUN_WINDOW_WIDTH \
	    $BASHRUN_WINDOW_HEIGHT
    done
}

