# -*- shell-script -*-

bashrun_window_id=""
bashrun_window_pos_x=0
bashrun_window_pos_y=0
bashrun_window_width=$COLUMNS
bashrun_window_height=$LINES
bashrun_window_pixel_width=$COLUMNS
bashrun_window_pixel_height=$LINES
bashrun_window_mapped=1
bashrun_window_animate=0
bashrun_window_hint=0
bashrun_window_hint_x=0
bashrun_window_hint_y=0

function §window? {
    [[ -n "$bashrun_window_id" ]]
}

function §window.exists? () {
    xwininfo -id "$1" &>/dev/null
}

function §window.mapped? {
    §window? || return 1
    [[ bashrun_window_mapped -eq 1 ]]
}

function §window.unmapped? {
    §window? || return 1
    [[ bashrun_window_mapped -eq 0 ]]
}

function §window.terminal? {
    §window? || return 1
    [[ "$bashrun_window_id" == "$WINDOWID" ]]
}

function §window.animate? {
     §window? || return 1
     [[ bashrun_window_animate -eq 1 ]]
}
function §window.animate {
    bashrun_window_animate=${1:-1}
}

function §window.hint? {
    [[ bashrun_window_hint -eq 1 ]]
}

function §window.id {
    
    if [[ $# -eq 0 ]]; then
	echo $bashrun_window_id
    elif [[ $# -eq 1 ]]; then
	bashrun_window_id=$1	    
	§window.update
    else
	bashrun_window_id=$1	    
	§window.update 1
    fi
    return 0
}

function §window.update {

    if [[ $# -eq 1 ]]; then
	# fast update, mapping state only
	if [[ "$(xwininfo -id $bashrun_window_id)" =~ "IsViewable" ]]; then
	    bashrun_window_mapped=1
	else
	    bashrun_window_mapped=0
	fi
	return 0
    fi

    # complete update...

    local saved="$IFS"
    local line=''
    local x y w h pw ph

    IFS=$'\n'
    for line in $(xwininfo -all -id $bashrun_window_id); do

	if [[ "$line" =~ "Width: "([0-9]+) ]]; then
	    (( pw+=${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Height: "([0-9]+) ]]; then
	    (( ph+=${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Relative upper-left X:  "([0-9]+) ]]; then
	    (( x -= ${BASH_REMATCH[1]} ))
	    (( pw = ${BASH_REMATCH[1]} * 2 )) # assume uniform border width
	fi

	if [[ "$line" =~ "Absolute upper-left Y:  "([0-9]+) ]]; then
	    (( y = ${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Relative upper-left Y:  "([0-9]+) ]]; then
	    (( y -= ${BASH_REMATCH[1]} ))
	    (( ph = ${BASH_REMATCH[1]} * 2 )) # assume uniform border width
	fi

	if [[ "$line" =~ "-geometry "([0-9]+)x([0-9]+) ]]; then
	    w=${BASH_REMATCH[1]}
	    h=${BASH_REMATCH[2]}
	fi

	if [[ "$line" =~ "Map State: "(.+) ]]; then
	    [[ ${BASH_REMATCH[1]} == 'IsUnMapped' ]] && bashrun_window_mapped=0
	    [[ ${BASH_REMATCH[1]} == 'IsViewable' ]] && bashrun_window_mapped=1
	fi

	if [[ "$line" =~ ([xy])\ resize\ increment:\ ([0-9]+) ]]; then
	    bashrun_window_hint=1
	    if [[ "${BASH_REMATCH[1]}" == "x" ]]; then
		bashrun_window_hint_x="${BASH_REMATCH[2]}"
		
	    elif [[ "${BASH_REMATCH[1]}" == "y" ]]; then
		bashrun_window_hint_y="${BASH_REMATCH[2]}"
	    fi
	fi
    done
    IFS="$saved"

    bashrun_window_pos_x=$x
    bashrun_window_pos_y=$y
    bashrun_window_width=$w
    bashrun_window_height=$h
    bashrun_window_pixel_width=$pw
    bashrun_window_pixel_height=$ph
    bashrun_window_animate="$(§mode.get_animated)"
}

function §window.geometry {

    §window.update
    if [[ "$(§geometry)" != "$1" ]]; then
	§geometry.parse "$1"
	§debug "Setting geometry" -v  "$1" 

	if §geometry.size?; then
	    §window.size --hint $(§geometry.width) $(§geometry.height)
	fi

	if §geometry.position?; then
	    §window.pos $(§geometry.x $bashrun_window_pixel_width) \
		$(§geometry.y $bashrun_window_pixel_height)	
	fi
    fi
}

function §window.pos {
    
    if [[ $# -eq 0 ]]; then
	§window.update
	echo $bashrun_window_pos_x $bashrun_window_pos_y
    else
	§window? || return 1
	
	local x="$1"
	local y="$2"
	
	if [[ "$x" =~ ([0-9]+)x([0-9]+) ]]; then
	    x=${BASH_REMATCH[1]}
	    y=${BASH_REMATCH[2]}
	fi
	
	brwctl $bashrun_window_id pos $x $y 
	bashrun_window_pos_x=$x
	bashrun_window_pos_y=$y
    fi
    return 0
}

function §window.resize {
    case $1 in
	up)
            (( bashrun_window_height-=1 ))
	    ;;
	down)
            (( bashrun_window_height+=1 ))
	    ;;
	left)
            (( bashrun_window_width-=1 ))
	    ;;
	right)
            (( bashrun_window_width+=1 ))
	    ;;
    esac
    [[ bashrun_window_height -lt 1 ]] && bashrun_window_height=1
    [[ bashrun_window_width -lt 1 ]] && bashrun_window_width=1
    §window.size --hint $bashrun_window_width $bashrun_window_height
}

function §window.size {
    
    # get window size
    if [[ $# -eq 0 ]]; then
	§window.update
	echo $bashrun_window_width $bashrun_window_height
	return 0;
    fi

    §window? || return 1

    # resize from the outside using brwctl (using xterms/urxvt's
    # escape sequences is unreliable, causing random freezes)

    local hint="size"
    if [[ "$1" == "--hint" ]]; then
	hint="sizeh"
	shift
    fi

    if [[ $# -eq 1 ]]; then
	if [[ "$width" =~ ([0-9]+)x([0-9]+) ]]; then
	    local w=${BASH_REMATCH[1]}
	    local h=${BASH_REMATCH[2]}
	    brwctl $bashrun_window_id hint $w $h
	    bashrun_window_width=$w
	    bashrun_window_height=$h
	fi
    fi

    if [[ $# -eq 2 ]]; then
	brwctl $bashrun_window_id $hint $1 $2
	bashrun_window_width=$1
	bashrun_window_height=$2
    fi 
        
    # apply completion threshold if necessary
    §window.terminal? && §completion.set $(§mode.get_completion)
    return 0
}
 
function §window.map {

    §window? || return 1
    [[ $# -eq 0 ]] && §window.update
    
    # map the window
    brwctl $bashrun_window_id show

    # parse geometry for this mode or use debug geometry
    if [[ BASHRUN_DEBUG -eq 0 ]]; then
	§geometry.parse "$(§mode.get_geometry 0)"
    else
	§geometry.parse "80x24"
    fi

    # apply position
    if §geometry.position?; then
	§window.pos "$(§geometry.x $bashrun_window_pixel_width)" \
	    "$(§geometry.y $bashrun_window_pixel_height)"
    fi

    # apply size
    if §geometry.size?; then
	§window.size --hint "$(§geometry.width)" \
	    "$(§geometry.height)"
    fi

    # call user supplied onmap handler
    $(§mode.get_onmap)
    
    if [[ bashrun_window_animate -eq 1 ]]; then
	§window.expand
    fi    
    bashrun_window_mapped=1
    return 0
}

function §window.unmap {

    §window? || return 1
    [[ $# -eq 0 ]] && §window.update

    if [[ bashrun_window_animate -eq 1 ]]; then
	§window.collapse
    fi
    brwctl $bashrun_window_id unmap

    # call user supplied onunmap handler    
    $(§mode.get_onunmap)

    bashrun_window_mapped=0
    return 0
}

function §window.toggle { # [smart] [fast]
    
    local smart=$1
    local fast=$2

    §window? || return 1
    §window.update $fast

    if [[ bashrun_window_mapped -eq 0 ]]; then	
	§window.map
    else
	if [[ smart -eq 1 ]]; then
	    if brwctl $bashrun_window_id focus?; then
		§window.unmap $fast
	    else
		§window.map $fast
	    fi
	else
	    §window.unmap $fast
	fi
    fi
    return 0
}

function §window.toggle_smart {
    §window.toggle 1 $1
}

function §window.collapse {

    local i=0
    for (( i=$bashrun_window_height; i>1; i-- )); do
	(( bashrun_window_height-=1 ))
	brwctl $bashrun_window_id sizeh \
	    $bashrun_window_width \
	    $bashrun_window_height
    done
}

function §window.expand {

    local max_height="$(§geometry.height)"

    [[ bashrun_window_height -ge max_height ]] && return 1

    local i=0
    for (( i=1; i<=max_height-1; i++ )); do
	(( bashrun_window_height+=1 ))
	brwctl $bashrun_window_id sizeh \
	    $bashrun_window_width \
	    $bashrun_window_height
    done
}

