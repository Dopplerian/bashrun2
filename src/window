# -*- shell-script -*-

BASHRUN_WINDOW_ID=""
BASHRUN_WINDOW_POS_X=0
BASHRUN_WINDOW_POS_Y=0
BASHRUN_WINDOW_WIDTH=$COLUMNS
BASHRUN_WINDOW_HEIGHT=$LINES
BASHRUN_WINDOW_PIXEL_WIDTH=$COLUMNS
BASHRUN_WINDOW_PIXEL_HEIGHT=$LINES
BASHRUN_WINDOW_MAPPED=1
BASHRUN_WINDOW_ANIMATE=0
BASHRUN_WINDOW_HINT=0
BASHRUN_WINDOW_HINT_X=0
BASHRUN_WINDOW_HINT_Y=0

function bashrun.window? {

    if [[ "$BASHRUN_WINDOW_ID" != '' ]]; then
	return 0
    fi
    return 1
}

function bashrun.window.mapped? {
    bashrun.window? || return 1

    [[ BASHRUN_WINDOW_MAPPED -eq 1 ]]
    return $?
}

function bashrun.window.terminal? {
    bashrun.window? || return 1
    if [[ "$TERM" =~ (xterm|rxvt) && "$BASHRUN_WINDOW_ID" == "$WINDOWID" ]]; then
	return 0
    fi
    return 1
}

function bashrun.window.animate? {
     bashrun.window? || return 1

    [[ BASHRUN_WINDOW_ANIMATE -eq 1 ]]
    return $?
}
function bashrun.window.animate {
    BASHRUN_WINDOW_ANIMATE=${1:-1}
}

function bashrun.window.hint? {
    [[ BASHRUN_WINDOW_HINT -eq 1 ]]
    return $?
}

function bashrun.window.id {
    
    if [[ $# -eq 0 ]]; then
	echo $BASHRUN_WINDOW_ID
    else
	BASHRUN_WINDOW_ID=$1	    
	bashrun.window.update
    fi
    return 0
}

function bashrun.window.update {

    local saved="$IFS"
    local line=''
    local x y w h pw ph

    IFS=$'\n'
    for line in $(xwininfo -all -id $BASHRUN_WINDOW_ID); do

	if [[ "$line" =~ "Width: "([0-9]+) ]]; then
	    (( pw+=${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Height: "([0-9]+) ]]; then
	    (( ph+=${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Relative upper-left X:  "([0-9]+) ]]; then
	    (( x -= ${BASH_REMATCH[1]} ))
	    (( pw = ${BASH_REMATCH[1]} * 2 )) # assume uniform border width
	fi

	if [[ "$line" =~ "Absolute upper-left Y:  "([0-9]+) ]]; then
	    (( y = ${BASH_REMATCH[1]} ))
	fi

	if [[ "$line" =~ "Relative upper-left Y:  "([0-9]+) ]]; then
	    (( y -= ${BASH_REMATCH[1]} ))
	    (( ph = ${BASH_REMATCH[1]} * 2 )) # assume uniform border width
	fi

	if [[ "$line" =~ "-geometry "([0-9]+)x([0-9]+) ]]; then
	    w=${BASH_REMATCH[1]}
	    h=${BASH_REMATCH[2]}
	fi

	if [[ "$line" =~ "Map State: "(.+) ]]; then
	    [[ ${BASH_REMATCH[1]} == 'IsUnMapped' ]] && BASHRUN_WINDOW_MAPPED=0
	    [[ ${BASH_REMATCH[1]} == 'IsViewable' ]] && BASHRUN_WINDOW_MAPPED=1
	fi

	if [[ "$line" =~ ([xy])\ resize\ increment:\ ([0-9]+) ]]; then
	    BASHRUN_WINDOW_HINT=1
	    if [[ "${BASH_REMATCH[1]}" == "x" ]]; then
		BASHRUN_WINDOW_HINT_X="${BASH_REMATCH[2]}"
		
	    elif [[ "${BASH_REMATCH[1]}" == "y" ]]; then
		BASHRUN_WINDOW_HINT_Y="${BASH_REMATCH[2]}"
	    fi
	fi
    done
    IFS="$saved"

    BASHRUN_WINDOW_POS_X=$x
    BASHRUN_WINDOW_POS_Y=$y
    BASHRUN_WINDOW_WIDTH=$w
    BASHRUN_WINDOW_HEIGHT=$h
    BASHRUN_WINDOW_PIXEL_WIDTH=$pw
    BASHRUN_WINDOW_PIXEL_HEIGHT=$ph

    local saved="$(mode.get_name)"
    if [ -f $BASHRUN_REGISTRY ]; then
	local mode="$(bashrun.registry.get_mode $BASHRUN_WINDOW_ID)"
	if [[ "$mode" != "none" ]]; then
	    modes.seek "$mode"
	    BASHRUN_WINDOW_ANIMATE="$(mode.get_anim)"
	    modes.seek "$saved"
	fi
    fi
}

function bashrun.window.geometry {

    bashrun.debug "Setting geometry" -v  "$1" 

    if [[ "$(geometry)" != "$1" ]]; then
	geometry.parse "$1"
    fi

    if geometry.size?; then
	bashrun.window.size --hint $(geometry.width) $(geometry.height)
    fi
    bashrun.window.update

    if geometry.position?; then
	bashrun.window.pos $(geometry.x $BASHRUN_WINDOW_PIXEL_WIDTH) \
	    $(geometry.y $BASHRUN_WINDOW_PIXEL_HEIGHT)	
    fi
}

function bashrun.window.pos {
   if [[ $# -eq 0 ]]; then
       bashrun.window.update
       echo $BASHRUN_WINDOW_POS_X $BASHRUN_WINDOW_POS_Y
   else
       bashrun.window? || return 1

       local x="$1"
       local y="$2"

       if [[ "$x" =~ ([0-9]+)x([0-9]+) ]]; then
	   x=${BASH_REMATCH[1]}
	   y=${BASH_REMATCH[2]}
       fi

       xdotool windowmove $BASHRUN_WINDOW_ID $x $y
       BASHRUN_WINDOW_POS_X=$x
       BASHRUN_WINDOW_POS_Y=$y
   fi
   return 0
}

function bashrun.window.size {
    
    if [[ $# -eq 0 ]]; then
	bashrun.window.update
	echo $BASHRUN_WINDOW_WIDTH $BASHRUN_WINDOW_HEIGHT
	return 0;
    fi

    bashrun.window? || return 1

    if ! bashrun.window.terminal?; then

	# resize from the outside using xdotool

	if [[ $# -eq 1 ]]; then
	    if [[ "$width" =~ ([0-9]+)x([0-9]+) ]]; then
		local w=${BASH_REMATCH[1]}
		local h=${BASH_REMATCH[2]}
		xdotool windowsize $BASHRUN_WINDOW_ID $w $h
		BASHRUN_WINDOW_WIDTH=$w
		BASHRUN_WINDOW_HEIGHT=$h
	    fi
	fi

	if [[ $# -eq 2 ]]; then
	    xdotool windowsize $BASHRUN_WINDOW_ID $1 $2
	    BASHRUN_WINDOW_WIDTH=$1
	    BASHRUN_WINDOW_HEIGHT=$2
	fi 
	
	if [[ $# -eq 3 && "$1" == "--hint" ]]; then
	    xdotool windowsize --usehints $BASHRUN_WINDOW_ID $2 $3
	    BASHRUN_WINDOW_WIDTH=$2
	    BASHRUN_WINDOW_HEIGHT=$3
	fi

    else
	# resize from the inside using ansi-escapes
        # args: [up|down|left|right] || columns lines || "<columns>x<lines>"

	if [[ "$1" == "--hint" ]]; then
	    shift
	fi

	local dir=$1
	local columns=$1
	local lines=$2
	local update=${3:-1}

        # set new BASHRUN_WINDOW_WIDTH, BASHRUN_WINDOW_HEIGHT
	case "$dir" in
	    up)
		let BASHRUN_WINDOW_HEIGHT--
		;;
	    down)
		let BASHRUN_WINDOW_HEIGHT++
		;;
	    left)
		let BASHRUN_WINDOW_WIDTH--
		;;
	    right)
		let BASHRUN_WINDOW_WIDTH++
		;;
	    *)
		if [[ "$columns" =~ ([0-9]+)x([0-9]+) ]]; then
		    columns=${BASH_REMATCH[1]}
		    lines=${BASH_REMATCH[2]}
		fi
		BASHRUN_WINDOW_WIDTH=$columns
		BASHRUN_WINDOW_HEIGHT=$lines
		;;
	esac
	
        # keep least 1x1
	[[ $BASHRUN_WINDOW_HEIGHT -eq 0 ]] && BASHRUN_WINDOW_HEIGHT=1
	[[ $BASHRUN_WINDOW_WIDTH -eq 0 ]] && BASHRUN_WINDOW_WIDTH=1
	
        # resize
	echo -ne "\e[8;${BASHRUN_WINDOW_HEIGHT};${BASHRUN_WINDOW_WIDTH}t";     

	COLUMNS=$BASHRUN_WINDOW_WIDTH
	LINES=$BASHRUN_WINDOW_HEIGHT
    fi
    completion.set $(mode.get_comp)
    return 0
}
 
function bashrun.window.map {

    local redraw=${1:-1}

    bashrun.window? || return 1
    bashrun.window.update
    
    modes.seek $(bashrun.registry.get_mode $BASHRUN_WINDOW_ID)

    # parse geometry for this mode 
    geometry.parse "$(echo $(mode.get_geom) | cut -d ' ' -f 1)"

    # map the window
    xdotool windowmap $BASHRUN_WINDOW_ID
    
    # apply position
    if geometry.position?; then
	bashrun.window.pos "$(geometry.x)" "$(geometry.y)"
    fi

    # move to the current desktop and focus
    xdotool set_desktop_for_window $BASHRUN_WINDOW_ID $(xdotool get_desktop)
    xdotool windowactivate $BASHRUN_WINDOW_ID
    xdotool windowfocus $BASHRUN_WINDOW_ID	
    
    # redraw-current-line
    if [[ redraw -eq 1 ]]; then
	xdotool key --clearmodifiers ctrl+x
	xdotool type --clearmodifiers 01
    fi

    # call user supplied onmap handler
    local onmap="$(mode.get_onmap)"
    [[ -n "$onmap" ]] && $onmap
    
    if [[ BASHRUN_WINDOW_ANIMATE -eq 1 ]]; then
	bashrun.window.expand
    fi    
    BASHRUN_WINDOW_MAPPED=1
    return 0
}

function bashrun.window.unmap {
    bashrun.window? || return 1
    bashrun.window.update

    modes.seek $(bashrun.registry.get_mode $BASHRUN_WINDOW_ID)

    if [[ BASHRUN_WINDOW_ANIMATE -eq 1 ]]; then
	bashrun.window.collapse
    fi
    xdotool windowunmap $BASHRUN_WINDOW_ID

    # call user supplied onunmap handler
    local onunmap="$(mode.get_onunmap)"
    [[ -n "$onunmap" ]] && $onunmap
    
    BASHRUN_WINDOW_MAPPED=0
    return 0
}

function bashrun.window.toggle {
    bashrun.window? || return 1
    bashrun.window.update

    if [[ BASHRUN_WINDOW_MAPPED -eq 0 ]]; then	
	bashrun.window.map
    else
	if [[ "$(xdotool getwindowfocus)" != $BASHRUN_WINDOW_ID ]]; then
	    bashrun.window.map
	else
	    bashrun.window.unmap
	fi
    fi
    return 0
}

function bashrun.window.collapse {

    local i=0
    for (( i=$BASHRUN_WINDOW_HEIGHT; i>1; i-- )); do
	(( BASHRUN_WINDOW_HEIGHT-=1 ))
	bashrun.window.size --hint $BASHRUN_WINDOW_WIDTH $BASHRUN_WINDOW_HEIGHT
    done
}

function bashrun.window.expand {

    local max_height="$(geometry.height)"

    [[ BASHRUN_WINDOW_HEIGHT -ge max_height ]] && return 1

    local i=0
    for (( i=1; i<=max_height-1; i++ )); do
	(( BASHRUN_WINDOW_HEIGHT+=1 ))
	bashrun.window.size --hint $BASHRUN_WINDOW_WIDTH $BASHRUN_WINDOW_HEIGHT
    done
}

