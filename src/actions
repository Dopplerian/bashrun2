# -*- shell-script -*-

################################################################################

object "action" "name type desc"

################################################################################

function actions_add {

    if actions_seek $1; then
	[[ $2 != '' ]] && action_set_desc "$2"
	[[ $3 != '' ]] && action_set_type "$3"
    else
	action_new $1 ${3:-trap-and-launch} "${2:-$1}"
    fi
}

function action_bind {

    local action=$(action_name)
    local type=$(action_type)

    local keyseq=$1
    local keymap=${2:-emacs}
    local keyname=${3:-$(ks2kn $keyseq)}

    local bind=''
    local accept='\C-z\x01'
    local char=''

    # if "pass", bind keyseq directly to accept-line (readline) and return
    if [[ "$action" == "pass" ]]; then
	bind="-m $keymap '\"$keyseq\": accept-line'"
	eval "bind $bind"
	return 0
    fi

    if ! internals_seek $action $keymap; then
	internal_new $action $keymap "new"
    fi
    internals_seek $action $keymap

    if [[ "$(internal_char)" == "new" ]]; then
	
        # no previous internal binding, get next invalid character to bind to
	char=$(printf "%.2X" $BASHRUN_BINDINGS_NEXT_CHAR)

	if [[ BASHRUN_BINDINGS_NEXT_CHAR -gt 0x7f ]]; then
	    bashrun_log "maximum number of internal keyseqs reached, skipping..." "fail"
	    return 1
	fi
	
	bind="-m $keymap -x \$'\"\C-z\\x$char\":"
	bind="$bind tput cr; bashrun_engine_action $action'"

	bashrun_log "int: $action ($type) -> \C-z\\x$char ($keymap)"
	eval "bind $bind"	    
	
	 # save char in internal	
	internal_set_char $char
	
	# next free char
	let BASHRUN_BINDINGS_NEXT_CHAR+=1
    else
	# there's already a internal character bound, use it
	char=$(internal_char)
	bashrun_log "redirecting: $action ($type) -> $char ($keymap)"
    fi
    
    # don't accept-line for 'launch' or 'shell' bindings
    if [[ "$type" != 'trap-and-launch' ]]; then
	accept=''
    fi

    # bind the requested keyseq to the internal character
    bind="-m $keymap '\"$keyseq\"':$'\"\C-z\x$char$accept\"'"
    
    # bind
    bashrun_log "usr: $action ($type) -> $keyname ($keymap)"
    eval "bind $bind"

    keyseq=$(qks $keyseq)
    
    # create or set binding
    if bindings_seek $keyseq $keymap; then
	binding_set_action $action
	binding_set_keymap $keymap
	binding_set_is_bound 1 
    else
	binding_new $keyseq $keymap $action 1
    fi    
    
    # create or set keyname
    if keynames_seek $keyseq; then
	keyname_set_name $keyname
    else
	keyname_new $keyseq $keyname
    fi
    return 0
}

function action_unbind {
    
    local action=$(action_name)

    local keymap=${1:-emacs}
    local keyseq=''
    local unbind=''
    local found=0
    local id=''
    
    # find the next bound binding
    for id in $(bindings_select action $action); do
	if bindings_seek $id $keymap; then
	    if binding_is_bound?; then
		found=1
		break
	    fi
	fi
    done
    [[ found -eq 0 ]] && return 1
    
    # get the keyseq that it's bound to
    keyseq=$(uks $(binding_keyseq))
    
    # unbind keyseq
    unbind="-m $keymap -r '$keyseq'"
    bashrun_log "$action from $keyseq ($keymap)"
    eval "bind $unbind"

    # clear binding
    binding_set_is_bound 0

    return 0
}

function action_rebind {

    local action=$(action_name)

    local keymap=${1:-emacs}
    local keyseq=''
    local found=0
    local id=''

    # find the next unbound binding
    for id in $(bindings_select action $action); do
	if bindings_seek $id $keymap; then
	    if ! binding_is_bound?; then
		found=1
		break
	    fi
	fi
    done
    [[ found -eq 0 ]] && return 1

    # get the keyseq that it was bound to before
    keyseq=$(uks $(binding_keyseq))

    action_bind $keyseq
    return $?
} 

function action_is_bound? {
    local action=$(action_name)
    local id=0

    for id in $(bindings_select is_bound 1); do
	bindings_seek $id
	if [[ "$(binding_action)" == $action ]]; then
	    return 0
	fi
    done
    return 1
}

function action_has_function? {
    type -t bashrun-action-$(action_name) &> /dev/null
    return $?
}

function action_run_function {

    function command {
	if [[ "$#" == "0" ]]; then
	    echo $BASHRUN_COMMAND
	else
	    BASHRUN_COMMAND="$@"
	    bashrun_log "$BASHRUN_COMMAND"
	fi
    }

    function line { echo $BASHRUN_COMMAND_LINE; }

    function executable? {
	bashrun_command_word_is_executable?
	return $?
    }

    function builtin? {
	bashrun_command_word_is_builtin?
	return $?
    }

    function handlers { handlers_apply; }
    function rules { :; }
    function terminal { :; }
    function root { :; }

    bashrun-action-$(action_name)
    
    unset -f \
	command \
	line \
	executable? \
	builtin? \
	handlers \
	rules \
	terminal \
	root
}

function action_code {
    
    local name=$(action_name)
    local desc=$(action_desc)
    local type=$(action_type)
    local id=''

    local code="$code bashrun-add-action"
    code="$code '$name'"
    [[ "$desc" != "$name" ]] && code="$code '$desc'"
    [[ "$type" != "trap-and-launch" ]] && code="$code '$type'"
    
    # print header
    print_line '#'
    echo -n "# $(action_name): $(action_desc)"
    echo -e '\n'

    if action_has_function?; then
	function_code "bashrun-action-$name"
    fi
    echo $code

    if action_is_bound?; then
	bindings_seek_start
	for id in $(bindings_select action $name); do
	    bindings_seek --next $id 
	    binding_code
	done
    fi
}

function actions_code {
    
    local saved="$(action_name)"

    actions_seek_start
    while actions_have_next; do
	action_code
	actions_next
	echo
    done
    actions_seek "$saved"
}

function actions_names {

    local saved="$(action_name)"

    actions_seek_start
    while actions_have_next; do
	echo -n "$(action_name) "
	actions_next
    done
    actions_seek "$saved"
    echo
}

################################################################################
