# -*- shell-script -*-

################################################################################

object "action" "name type desc deps help" "bind unbind rebind"

################################################################################

function_clone "action.new" "_action.new"

function action.new {

    _action.new "$1"
    action.set_type "trap-and-launch"
    action.set_desc "$1"

    if ! type -t action-$1 &> /dev/null; then
	eval "
	action-$1 ()
	{ 
	    ! executable? && +handlers
	    +terminal
	    return 0
	}"
    fi
}

function action.bind {

    local action=$(action.get_name)
    local type=$(action.get_type)

    local keyseq=$1
    local keymap=${2:-emacs}
    local keyname=${3:-$(ks2kn $keyseq)}

    local bind=''
    local accept='\C-z\x01'
    local char=''

    # if "pass", bind keyseq directly to accept-line (readline) and return
    if [[ "$action" == "pass" ]]; then
	bind="-m $keymap '\"$keyseq\": accept-line'"
	eval "bind $bind"
	# create or set binding
	if bindings.seek $keyseq $keymap; then
	    binding.set_action $action
	    binding.set_keymap $keymap	    
	    binding.set_is_bound 1 
	    binding.set_readline "$bind"
	else
	    binding.new "$keyseq" "$keymap" "$action" "1" "$bind"
	fi    
	return 0
    fi

    if ! internals.seek $action $keymap; then
	internal.new $action $keymap "new"
    fi
    internals.seek $action $keymap

    if [[ "$(internal.get_char)" == "new" ]]; then
	
        # no previous internal binding, get next invalid character to bind to
	char=$(printf "%.2X" $BASHRUN_BINDINGS_NEXT_CHAR)

	if [[ BASHRUN_BINDINGS_NEXT_CHAR -gt 0x7f ]]; then
	    bashrun_log "maximum number of internal keyseqs reached, skipping..." "fail"
	    return 1
	fi
	
	bind="-m $keymap -x \$'\"\C-z\\x$char\":"
	bind="$bind tput cr; bashrun_engine_action $action'"

	bashrun_log "int: $action ($type) -> \C-z\\x$char ($keymap)"
	# echo "bind $bind"
	eval "bind $bind"	    
	
	#save readline binding in internal
	internal.set_readline "$bind"

	# save char in internal	
	internal.set_char $char
	
	# next free char
	let BASHRUN_BINDINGS_NEXT_CHAR+=1
    else
	# there's already a internal character bound, use it
	char=$(internal.get_char)
	bashrun_log "redirecting: $action ($type) -> $char ($keymap)"
    fi
    
    # don't accept-line for 'launch' or 'shell' bindings
    if [[ "$type" != 'trap-and-launch' ]]; then
	accept=''
    fi

    # bind the requested keyseq to the internal character
    bind="-m $keymap '\"$keyseq\"':$'\"\C-z\x$char$accept\"'"
    
    # bind
    bashrun_log "usr: $action ($type) -> $keyname ($keymap)"
    # echo "bind $bind"
    eval "bind $bind"

    # create or set binding
    if bindings.seek $keyseq $keymap; then
	binding.set_action $action
	binding.set_keymap $keymap
	binding.set_is_bound 1 
	binding.set_readline "$bind" 
    else
	binding.new $keyseq $keymap $action 1 "$bind"
    fi    
    
    # create or set keyname
    if keynames.seek $keyseq; then
	keyname.set_name $keyname
    else
	keyname.new $keyseq $keyname
    fi
    return 0
}

function action.unbind {
    
    local action=$(action.get_name)
    local keymap=${1:-emacs}
    local keyseq=$2
    local unbind=''
    local found=0
    local id=''

    if [[ "$keyseq" == '' ]]; then
        # find the next bound binding
	for id in $(bindings.select action $action); do
	    if bindings.seek $id $keymap; then
		if binding.bound?; then
		    found=1
		    break
		fi
	    fi
	done
	[[ found -eq 0 ]] && return 1
	
        # get the keyseq that it's bound to
	keyseq=$(binding.get_keyseq)
    fi
    
    # unbind keyseq
    unbind="-m $keymap -r '$keyseq'"
    bashrun_log "$action from $keyseq ($keymap)"
    eval "bind $unbind"

    # rebind original readline binding
    readline_rebind "$keyseq" "$keymap"

    # clear binding
    binding.set_is_bound 0

    return 0
}

function action.rebind {

    local action=$(action.get_name)

    local keymap=${1:-emacs}
    local keyseq=''
    local found=0
    local id=''

    # find the next unbound binding
    for id in $(bindings.select action $action); do
	if bindings.seek $id $keymap; then
	    if ! binding.bound?; then
		found=1
		break
	    fi
	fi
    done
    [[ found -eq 0 ]] && return 1

    # get the keyseq that it was bound to before
    keyseq=$(binding.get_keyseq)

    action.bind $keyseq
    return $?
} 

function action.bound? {
    local action=$(action.get_name)
    local id=0

    for id in $(bindings.select is_bound 1); do
	bindings.seek $id
	if [[ "$(binding.get_action)" == $action ]]; then
	    return 0
	fi
    done
    return 1
}

function action.function? {
    type -t action-$(action.get_name) &> /dev/null
    return $?
}

function action.available? {

    local dep=''
    declare -i result=0

    for dep in $(action.get_deps); do
	if ! `which $dep &> /dev/null`; then
	    result=1
	fi
    done
    return $result
}

function action.uses {

    local code="$(type action-$(action.get_name))"
    local applies=""
    local methods=""
    methods="$methods §command §line §handlers §rules §terminal §user"

    local method=''
    for method in $methods; do
	if [[ "$code" =~ ${method} ]]; then
	    if [[ "$method" == "§user" ]]; then
		if [[ "$code" =~ §user\ +?([^\}\;]+) ]]; then 
		    applies="$applies, user:${BASH_REMATCH[1]}"
		fi
	    else
		applies="$applies, ${method/§/}"
	    fi
	fi
    done
    applies="${applies:2}"
    echo "$applies"
}

function action.run_function {
    
    local action=$(action.get_name)

    local retval
    declare -i retval

    # enable the action interface
    action.runtime_interface_create

    # run the action function
    action-$(action.get_name)
    retval=$?

    # disable the action interface
    action.runtime_interface_destroy

    local msg="action-$action returned $retval ->"
    [[ retval -eq 0 ]] && msg="$msg execute"
    [[ retval -eq 1 ]] && msg="$msg done"
    bashrun_log "$msg"

    return $retval
}

function action.runtime_interface_create {

    function command {
	if [[ "$#" == "0" ]]; then
	    echo $BASHRUN_COMMAND
	else
	    BASHRUN_COMMAND="$@"
	    bashrun_log "$BASHRUN_COMMAND"
	fi
    }

    function line { echo $BASHRUN_COMMAND_LINE; }

    function executable? {
	bashrun_command_word_is_executable?
	return $?
    }

    function builtin? {
	bashrun_command_word_is_builtin?
	return $?
    }

    function bookmark? {
	bashrun_command_word_is_bookmark?
    }
    
    function +handlers { handlers.apply; }
    function +rules { :; }
    function +terminal { bashrun_command_wrap_in_terminal; }
    function +user { bashrun_command_wrap_in_su ${1:-root}; }
}

function action.runtime_interface_destroy {

        unset -f \
	    command \
	    line \
	    executable? \
	    builtin? \
	    bookmark? \
	    +handlers \
	    +rules \
	    +terminal \
	    +user
}

function action.pretty_print_deps {

    local dep=''
    local deps="$(action.get_deps)"
    local str=''
    local found=$R

    if [[ $deps != '' ]]; then
	
	for dep in $deps; do
	    if `which $dep &> /dev/null`; then
		found=$G
	    else
		found=$R
	    fi
	    str=", $found$dep$N$str" 
	done
	str="${str:2}"
	echo -ne "$str"
    fi
}

function action.list {

    local name=$(action.get_name)
    local desc=$(action.get_desc)
    local type=$(action.get_type)
    local deps=$(action.get_deps)
    local help=$(action.get_help)
    local uses=$(action.uses)
    
    # print header
    print_header "$name -> $desc" "-"

    echo "type: $type"

    if [[ $deps != '' ]]; then
	echo -e "deps: $(action.pretty_print_deps)"
    fi

    if [[ "$uses" != '' ]]; then
	echo "uses: $uses"
    fi
    echo

    local id=''
    if action.bound?; then
	bindings.seek_start
	for id in $(bindings.select action $name); do
	    bindings.seek --next $id 
	    echo -ne '\t'
	    echo "$(ks2kn $(binding.get_keyseq)) ($(binding.get_keymap)-mode)"
	done
	echo
    fi

    if [[ "$help" != '' ]]; then
	echo "$help"
	echo
    fi
}

function action.code {
    
    local name=$(action.get_name)
    local desc=$(action.get_desc)
    local type=$(action.get_type)
    local deps=$(action.get_deps)
    local help=$(action.get_help)

    print_line "" '#' 80
    print_line "$name" "#" "-1"
    echo

    # add action 
    echo "+action --new '$name'"
    echo "--desc '$desc'"
    echo "--type '$type'"
    [[ "$deps" != "" ]] && echo "--deps '$deps'"
    [[ "$help" != "" ]] && echo "--help '$help'"
    
    # bind action
    local id=''
    if action.bound?; then
	bindings.seek_start
	for id in $(bindings.select action $name); do
	    bindings.seek --next $id 
	    binding.code
	done
    fi
    echo

    # function
    if action.function?; then
	function_code "action-$name"
    fi
    echo
}

function_clone "actions.dump" "_actions.dump"

function actions.dump {

    local file=$_OBJECTS_HOME/actions
    local action=''

    _actions.dump

    actions.seek_start
    while actions.next?; do
	action=$(action.get_name)
	function_code "action-$action" >> $file
	actions.next
    done    
}


################################################################################
