# -*- shell-script -*-

################################################################################

# "class variables" ############################################################

_OBJECTS=()
_OBJECTS_KEYS=()
_OBJECTS_WIDTH=${#_OBJECTS_KEYS[@]}
_OBJECTS_POSITION=0
_OBJECTS_NEXT=0
_OBJECTS_SIZE=0
_OBJECTS_MODIFIED=0

_OBJECTS_HAVE_INTERFACE=0
_OBJECTS_INTERFACE_METHODS=''
_OBJECTS_INTERFACE_OPTIONS=''
_OBJECTS_INTERFACE_OPTIONS_FOUND=()

# "class methods" (seeking to, matching and iterating objects) #################

function objects.seek { # args
    
    local matched=0
    local num_args=$#
    local start=0
    local saved=$_OBJECTS_POSITION
    local next=0
    local i=0

    if [[ num_args -eq 0 ]]; then
	return 0
    fi

    if [[ "$1" == "--next" ]]; then	
	next=1
	start=$_OBJECTS_NEXT
	shift
	(( num_args-=1 ))
    fi

    for ((i=$start; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	matched=0
	if [[ "${_OBJECTS[$i]}" == "$1" ]]; then
	    matched=1
	    if [[ $num_args -eq 2 ]]; then
		if [[ "${_OBJECTS[$i+1]}" == "$2" ]]; then
		    matched=1
		else
		    matched=0		    
		fi
	    fi		
	fi

	if [[ matched -eq 1 ]]; then
	    _OBJECTS_POSITION=$i
	    break
	fi	
    done

    if [[ next -eq 1 ]]; then 
	(( _OBJECTS_NEXT = _OBJECTS_POSITION + _OBJECTS_WIDTH ))
	if [[ _OBJECTS_NEXT -ge ${#_OBJECTS[@]} ]]; then
	    _OBJECTS_NEXT=0
	fi
    fi

    if [[ matched -eq 0 ]]; then
	_OBJECTS_POSITION=$saved
	return 1
    else
	return 0
    fi
}

function objects.seek_start {
    _OBJECTS_POSITION=0
    _OBJECTS_NEXT=0
}

function objects.seek_end {
    (( _OBJECTS_POSITION = (_OBJECTS_SIZE-1) * _OBJECTS_WIDTH ))
    _OBJECTS_NEXT=0
}

function objects.next? {
    [[ $_OBJECTS_POSITION+$_OBJECTS_WIDTH -le ${#_OBJECTS[@]} ]] && return 0
    return 1
}

function objects.current {
    echo "${_OBJECTS[$_OBJECTS_POSITION]}"
}

function objects.next {
    (( _OBJECTS_POSITION += _OBJECTS_WIDTH ))
}

function objects.previous? {
    [[ $_OBJECTS_POSITION+1 -ge 0 ]] && return 0
    _OBJECTS_POSITION=0
    return 1
}

function objects.previous {
    (( _OBJECTS_POSITION -= _OBJECTS_WIDTH ))
}

function objects.select { # key value [which=0]-> "id1 id2..."

    local key=$1
    local wanted=$2
    local which=${3:-1} # 0: any, 1: all
    local regexp=''
    local value=''
    local ids=''
    local i=0
    local saved=${_OBJECTS[$_OBJECTS_POSITION]}

    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	_OBJECTS_POSITION=$i
	
	value=$(object.get $key)
	if [[ "$value" == "$wanted" ]]; then
	    # literal match
	    ids="$ids ${_OBJECTS[$i]}"
	    [[ which -eq 0 ]] && break
	    
	elif [[ "$wanted" =~ ^/.+?/$ ]]; then
	    # regexp given
	    regexp=${wanted:1:${#wanted}-2}
	    
	    if [[ "$value" =~ $regexp ]]; then
		# regexp match
		ids="$ids ${_OBJECTS[$i]}"
		[[ which -eq 0 ]] && break
	    fi
	fi
    done
    objects.seek $saved
    [[ "${ids:0:1}" == " " ]] && ids="${ids:1}"
	
    echo "$ids"
}

function objects.modified? {

    [[ _OBJECTS_MODIFIED -eq 0 ]] && return 1
    [[ _OBJECTS_MODIFIED -eq 1 ]] && return 0
}

function objects.modified { # value
    _OBJECTS_MODIFIED=$1
}

function objects.interface? {
    [[ _OBJECTS_HAVE_INTERFACE -eq 1 ]] && return 0
    [[ _OBJECTS_HAVE_INTERFACE -eq 0 ]] && return 1
}

function objects.list { # [-l] [ids]

    local current=$_OBJECTS_POSITION
    local opt=''

    while [[ "${1:0:1}" == "-" ]]; do
	if [[ "$1" == "-l" ]]; then
	    opt="$1"
	fi
	shift
    done

    if [[ "$1" != '' ]]; then
	for id in $@; do
	    if [[ "$id" == "." ]]; then
		id=${_OBJECTS[$current]}
	    fi
	    
	    if objects.seek $id; then
		object.list -l $id
	    fi
	done
    else
	objects.seek_start
	while objects.next?; do
	    object.list $opt
	    objects.next
	done
    _OBJECTS_POSITION=$current
    fi
}

function objects.all {
    
    local i=0
    local all=""
    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	all="$all ${_OBJECTS[$i]}"
    done
    echo "${all:1}"
}

function objects.dump {
    
    local data="$(printf "%q " "${_OBJECTS[@]}")"

    echo "
    _OBJECTS_KEYS=(${_OBJECTS_KEYS[@]})
    _OBJECTS_WIDTH=${_OBJECTS_WIDTH}
    _OBJECTS_POSITION=0
    _OBJECTS_NEXT=0
    _OBJECTS_SIZE=${_OBJECTS_SIZE}
    _OBJECTS_MODIFIED=0
    
    _OBJECTS_HAVE_INTERFACE=${_OBJECTS_HAVE_INTERFACE}
    _OBJECTS_INTERFACE_METHODS='${_OBJECTS_INTERFACE_METHODS}'
    _OBJECTS_INTERFACE_OPTIONS='${_OBJECTS_INTERFACE_OPTIONS}'
    _OBJECTS_INTERFACE_OPTIONS_FOUND=()

    _OBJECTS=($data)
    " > $_ObJeCtS_DATA_HOME/${1:-objects.dump}

}

function objects.restore {
    local file=$_ObJeCtS_DATA_HOME/objects.dump
    [[ -f "$file" ]] && . "$file"
}

function objects.clear {
    _OBJECTS=()
    _OBJECTS_POSITION=0
    _OBJECTS_NEXT=0
    _OBJECTS_SIZE=0
    _OBJECTS_MODIFIED=1
}

# "instance methods" (always operate on the object at the current position) ####

function object.new {
    local i

    for ((i=1; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	_OBJECTS[${#_OBJECTS[@]}]=${!i}
    done
    (( _OBJECTS_SIZE+=1 ))
    _OBJECTS_MODIFIED=1
    objects.seek $1
}

function object.delete {

    local start=$_OBJECTS_POSITION
    local width=$_OBJECTS_WIDTH

    for((i=$start; i<=$start+$width-1; i++)); do
	unset _OBJECTS[$i]
    done

    local objects="$(printf '%q ' "${_OBJECTS[@]}")"
    eval "_OBJECTS=($objects)"

    _OBJECTS_POSITION=0
    (( _OBJECTS_SIZE-=1 ))
    _OBJECTS_MODIFIED=1
}

function object.id {
    objects.current
}

function object.get { # key -> "value"
    local key=$1
    local index=-1
    local i=0
 
    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then 
	echo "${_OBJECTS[$_OBJECTS_POSITION+$index]}"
    fi
}

function object.set { # key value

    local key=$1
    local value=$2
    local index=-1
    local i=0

    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then
	_OBJECTS[$_OBJECTS_POSITION+$index]=$value
	_OBJECTS_MODIFIED=1
    fi
}

function object.code {
    
    local i=0;
    local pos=0
    local args=''
    
    for ((i=0; i<${_OBJECTS_WIDTH}; i++)); do
	(( pos = _OBJECTS_POSITION + i ))
	args="$args '${_OBJECTS[$pos]}'"
    done
    args="${args:1}"

    echo "object.new $args"
}

function objects.code {

    print_header 'OBJECTS' '#'

    objects.seek_start
    while objects.next?; do
	object.code
	objects.next
    done
    objects.seek_start
    echo
}
    
function object.list {
    local opt="$1"

    if [[ "$opt" == '-l' ]]; then
	local key
	for key in ${_OBJECTS_KEYS[@]}; do
	    echo "$key: $(object.get $key)"
	done;
	echo
    else
	echo $(object.id)
    fi
}

################################################################################
## INTERFACE

if [[ _OBJECTS_HAVE_INTERFACE -eq 1 ]]; then

    function objects.ui.enable {
	local opt=''
	for opt in $_OBJECTS_INTERFACE_OPTIONS; do
	    eval "function $opt {
		+object $opt \"\$@\"
	    }"
	done
    }
    
    function objects.ui.disable {
	local opt=''
	for opt in $_OBJECTS_INTERFACE_OPTIONS; do
	    unset -f -- $opt
	done
    } 
    
    function +object {
	
	# remove a previous type's interface
	local switched=0
	local destroy_interface="${_ObJeCtS_FOCUS}s.ui.disable"
	if [[ "$_ObJeCtS_FOCUS" != "object" ]]; then
	    if [[ "$_ObJeCtS_FOCUS" != '' ]]; then
		if $(type -t $destroy_interface &> /dev/null); then
		    eval "$destroy_interface"
		    switched=1
		fi
	    fi
	    objects.ui.enable
	fi

	# set global current object type
	_ObJeCtS_FOCUS="object"

        # no arg -> return (setting focussed type is sideeffect)
	if [[ "$#" == "0" ]]; then
	    return 0
	fi

	# parse commandline arguments	
	local current=""
	local left=()
	local var=''
	local expect='arg' # optarg or arg       

	while [[ "$1" != '' ]]; do
	    
	    if [[ "${1:0:2}" == "--" ]]; then
		current="${1:2}"
		eval "_OBJECTS_INTERFACE_OPTION_$current=''"
		_OBJECTS_INTERFACE_OPTIONS_FOUND[${#_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}]="$current"		
		expect='optarg'
	    else
		if [[ "$expect" == "optarg" ]]; then
		    var="_OBJECTS_INTERFACE_OPTION_$current" 
		    val="${!var} $1"
		    val=$(printf '%q ' "$val") 		    
		    val=${val//\$/\\\\\$}
		    val=${val//\"/\\\\\"}
		    eval "$var=$val"
		else
		    left[${#left[@]}]="$1"
		fi
	    fi
	    shift
	done

	# trim leading whitespace from values
	local func=''
	for f in ${_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}; do
	    var="_OBJECTS_INTERFACE_OPTION_$f"
	    eval "$var=\"${!var:1}\""
	done
	
	# --new
	var="_OBJECTS_INTERFACE_OPTION_new"
	if defined? $var; then
	    if [[ ${!var} != '' ]]; then
		if ! objects.seek ${!var}; then
		    object.new "${!var}"
		fi
	    else
		echo "--new: syntax error: name argument missing"
		return 1
	    fi
	fi

	# get objects       
	local which=""
	var="_OBJECTS_INTERFACE_OPTION_all"

	if defined? $var; then
	    which="$(objects.all)"
	else
	    if [[ "${#left[@]}" != "0" ]]; then
		which="${left[@]}"
	    else
		which="$(objects.current)"
	    fi
	fi
	
	local id=''
	for id in $which; do

	    # seek object
	    if ! objects.seek $id; then
		object.new "$id"
	    fi

	    local i=0
	    local key=''
	    local var=''
	    local val=''
	    
	    # --code
	    var="_OBJECTS_INTERFACE_OPTION_code"
	    if defined? $var; then	    
		object.code
	    fi
	    
	    # call methods
	    local method=''
	    local args=''
	    for method in $_OBJECTS_INTERFACE_METHODS; do
		var="_OBJECTS_INTERFACE_OPTION_$method"
		if defined? $var; then
		    if $(type -t object.$method &> /dev/null); then
			args="${!var}"
			args=${args//\\/\\\\}
			eval "object.$method $args"
		    else
			echo "method object.$method not implemented."
		    fi
		fi
	    done
	    
	    # get/set attributes
	    for ((i=0; i<${#_OBJECTS_KEYS[@]}; i++)); do
		key=${_OBJECTS_KEYS[$i]}
		var="_OBJECTS_INTERFACE_OPTION_$key"

		if defined? $var; then
		    val="${!var}"
		    if [[ "$val" == '' ]]; then
			object.get_$key
		    else
			object.set_$key "$val"			
		    fi
		fi
	    done	
	done

        # cleanup all _OBJECTS_INTERFACE_OPTION_* vars

	local f=''
	for f in ${_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}; do
	    var="_OBJECTS_INTERFACE_OPTION_$f"
	    unset $var
	done
	_OBJECTS_INTERFACE_OPTIONS_FOUND=()
    }
    
    # completion
    function objects.complete {

	local cur prev opts
	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	prev="${COMP_WORDS[COMP_CWORD-1]}"
	opts="$(objects.all)"

	if [[ ${cur} == * ]]; then
	    if [[ ${cur} =~ ^\- ]]; then
		cur=${cur//-/\\-}
		COMPREPLY=( $(compgen -W "${_OBJECTS_INTERFACE_OPTIONS}" ${cur}) )
	    else
		cur=${cur//-/\\-}
		COMPREPLY=( $(compgen -W "${opts} ${_OBJECTS_INTERFACE_OPTIONS}" ${cur}) )
	    fi
	fi
        return 0
    }

    complete -o default -F objects.complete +object
    
    # experimental configuration interface using dialog

    function objects.configure {
	local items=""
	objects.seek_start
	while objects.next?; do
	    items="$items '$(object.get_name)' '$(object.get_desc)'"
	    objects.next
	done
	objects.seek_start
	eval "dialog --stderr --menu 'objects' $((LINES-3)) $((COLUMNS-5)) $((LINES-3)) $items 2> /tmp/answer"
	local answer="$(cat /tmp/answer)"
	if [[ -n answer ]]; then
	    objects.seek $answer
	    object.configure
	fi
    }
    
    function object.configure {
	echo "object.configure(): not implemented"
    }
    
fi # end _OBJECTS_HAVE_INTERFACE

# "instance accessor methods" (generated by object) ###########


