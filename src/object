# -*- shell-script -*-

################################################################################

_OBJECTS=()
_OBJECTS_KEYS=()
_OBJECTS_WIDTH=${#_OBJECTS_KEYS[@]}
_OBJECTS_POSITION=0
_OBJECTS_SIZE=0
_OBJECTS_MODIFIED=0

_OBJECTS_HAVE_INTERFACE=0
_OBJECTS_INTERFACE_METHODS=''
_OBJECTS_INTERFACE_OPTIONS=''

function objects.seek { # args

    local matched=0
    local start=0
    local saved=$_OBJECTS_POSITION
    local cardinal=${#_OBJECTS[@]}

    local i=0
    for (( i=$start; i<=$cardinal; i+=$_OBJECTS_WIDTH )); do
	matched=0
	if [[ "${_OBJECTS[$i]}" == "$1" ]]; then
	    matched=1
	    if [[ $# -eq 2 ]]; then
		if [[ "${_OBJECTS[$i+1]}" == "$2" ]]; then
		    matched=1
		else
		    matched=0		    
		fi
	    fi		
	fi

	if [[ matched -eq 1 ]]; then
	    _OBJECTS_POSITION=$i
	    break
	fi	
    done

    if [[ matched -eq 0 ]]; then
	_OBJECTS_POSITION=$saved
	return 1
    else
	return 0
    fi
}

function objects.seek_start {
    _OBJECTS_POSITION=0
}

function objects.seek_end {
    (( _OBJECTS_POSITION = (_OBJECTS_SIZE-1) * _OBJECTS_WIDTH ))
}

function objects.next? {
    [[ $_OBJECTS_POSITION+$_OBJECTS_WIDTH -le ${#_OBJECTS[@]} ]] && return 0
    return 1
}

function objects.current {
    echo "${_OBJECTS[$_OBJECTS_POSITION]}"
}

function objects.next {
    (( _OBJECTS_POSITION += _OBJECTS_WIDTH ))
}

function objects.previous? {
    [[ $_OBJECTS_POSITION+1 -ge 0 ]] && return 0
    _OBJECTS_POSITION=0
    return 1
}

function objects.previous {
    (( _OBJECTS_POSITION -= _OBJECTS_WIDTH ))
}

function objects.select { # key value [which=0]-> "id1 id2..."

    local key=$1
    local wanted=$2
    local which=${3:-1} # 0: any, 1: all
    local regexp=''
    local value=''
    local ids=''
    local i=0
    local saved=${_OBJECTS[$_OBJECTS_POSITION]}

    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	_OBJECTS_POSITION=$i
	
	value=$(object.get $key)
	if [[ "$value" == "$wanted" ]]; then
	    # literal match
	    ids="$ids ${_OBJECTS[$i]}"
	    [[ which -eq 0 ]] && break
	    
	elif [[ "$wanted" =~ ^/.+?/$ ]]; then
	    # regexp given
	    regexp=${wanted:1:${#wanted}-2}
	    
	    if [[ "$value" =~ $regexp ]]; then
		# regexp match
		ids="$ids ${_OBJECTS[$i]}"
		[[ which -eq 0 ]] && break
	    fi
	fi
    done
    objects.seek $saved
    [[ "${ids:0:1}" == " " ]] && ids="${ids:1}"
	
    echo "$ids"
}

function objects.modified? {

    [[ _OBJECTS_MODIFIED -eq 0 ]] && return 1
    [[ _OBJECTS_MODIFIED -eq 1 ]] && return 0
}

function objects.modified { # value
    _OBJECTS_MODIFIED=$1
}

function objects.interface? {
    [[ _OBJECTS_HAVE_INTERFACE -eq 1 ]] && return 0
    [[ _OBJECTS_HAVE_INTERFACE -eq 0 ]] && return 1
}

function objects.size {
    echo "$_OBJECTS_SIZE"
}

function objects.empty? {
    [[ _OBJECTS_SIZE -eq 0 ]]
}

function objects.list { # [-l] [ids]

    local current=$_OBJECTS_POSITION
    local opt=''

    while [[ "${1:0:1}" == "-" ]]; do
	if [[ "$1" == "-l" ]]; then
	    opt="$1"
	fi
	shift
    done

    if [[ "$1" != '' ]]; then
	for id in $@; do
	    if [[ "$id" == "." ]]; then
		id=${_OBJECTS[$current]}
	    fi
	    
	    if objects.seek $id; then
		object.list -l $id
	    fi
	done
    else
	objects.seek_start
	while objects.next?; do
	    object.list $opt
	    objects.next
	done
    _OBJECTS_POSITION=$current
    fi
}

function objects.all {
    
    local i=0
    local all=""
    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	all="$all ${_OBJECTS[$i]}"
    done
    echo "${all:1}"
}

function objects.init {
    
    local i=0
    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	_OBJECTS_POSITION=$i
	object.init
    done
    _OBJECTS_POSITION=0
}

function objects.dump {
    
    local dumpfile="$_ObJeCtS_DATA_HOME/${1:-objects.dump}"

    if objects.empty?; then
	touch $dumpfile
	return 0
    fi

    local data="$(printf "%q " "${_OBJECTS[@]}")"

    local dump="
        _OBJECTS_KEYS=(${_OBJECTS_KEYS[@]})
        _OBJECTS_WIDTH=${_OBJECTS_WIDTH}
        _OBJECTS_POSITION=0
        _OBJECTS_SIZE=${_OBJECTS_SIZE}
        _OBJECTS_MODIFIED=0
    
        _OBJECTS_HAVE_INTERFACE=${_OBJECTS_HAVE_INTERFACE}
        _OBJECTS_INTERFACE_METHODS='${_OBJECTS_INTERFACE_METHODS}'
        _OBJECTS_INTERFACE_OPTIONS='${_OBJECTS_INTERFACE_OPTIONS}'
        _OBJECTS_INTERFACE_OPTIONS_FOUND=()

        _OBJECTS=($data)
        "

    if [[ "$2" == "append" ]]; then
        echo "$dump" >> $dumpfile
    else
        echo "$dump" > $dumpfile
    fi
}

function objects.restore {
    local file=$_ObJeCtS_DATA_HOME/${1:-objects.dump}
    [[ -f "$file" ]] && . "$file"
}

function objects.clear {
    _OBJECTS=()
    _OBJECTS_POSITION=0
    _OBJECTS_SIZE=0
    _OBJECTS_MODIFIED=1
}

# "instance methods" (always operate on the object at the current position) ####

function object.new {
    local i

    for ((i=1; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	_OBJECTS[${#_OBJECTS[@]}]=${!i}
    done
    (( _OBJECTS_SIZE+=1 ))
    _OBJECTS_MODIFIED=1
    objects.seek $1
}
function object.init { :; }

function object.delete {

    local start=$_OBJECTS_POSITION
    local width=$_OBJECTS_WIDTH
    local i=0

    for((i=$start; i<=$start+$width-1; i++)); do
	unset _OBJECTS[$i]
    done

    local objects="$(printf '%q ' "${_OBJECTS[@]}")"
    eval "_OBJECTS=($objects)"

    _OBJECTS_POSITION=0
    (( _OBJECTS_SIZE-=1 ))
    _OBJECTS_MODIFIED=1
}

function object.id {
    objects.current
}

function object.get { # key -> "value"
    local key=$1
    local index=-1
    local i=0
 
    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then 
	echo "${_OBJECTS[$_OBJECTS_POSITION+$index]}"
    fi
}

function object.set { # key value

    local key=$1
    local value=$2
    local index=-1
    local i=0

    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then
	_OBJECTS[$_OBJECTS_POSITION+$index]=$value
	_OBJECTS_MODIFIED=1
    fi
}

function object.first? { # [key]
    if [[ $# -eq 1 ]]; then
	[[  "$1" == "$(objects.current)" ]]
    else
	[[ _OBJECTS_POSITION -eq 0  ]]
    fi
}

function object.last? { # [key]
    local i
    (( i = (_OBJECTS_SIZE-1) * _OBJECTS_WIDTH ))
    local id=${_OBJECTS[$i]}

    if [[ $# -eq 1 ]]; then
	[[ "$id" == "$1" ]]
    else
	[[ "$id" == "$(objects.current)" ]]
    fi
}

function object.code {
    
    local i=0;
    local pos=0
    local args=''
    
    for ((i=0; i<${_OBJECTS_WIDTH}; i++)); do
	(( pos = _OBJECTS_POSITION + i ))
	args="$args '${_OBJECTS[$pos]}'"
    done
    args="${args:1}"

    echo "object.new $args"
}

function objects.code {

    objects.seek_start
    while objects.next?; do
	object.code
	objects.next
    done
    objects.seek_start
    echo
}
    
function object.list {
    local opt="$1"

    if [[ "$opt" == '-l' ]]; then
	local key
	for key in ${_OBJECTS_KEYS[@]}; do
	    echo "$key: $(object.get $key)"
	done;
	echo
    else
	echo $(object.id)
    fi
}

################################################################################
## INTERFACE

if [[ _OBJECTS_HAVE_INTERFACE -eq 1 ]]; then

    function objects.ui.enable {
	local opt='' optname=''

	for opt in $_OBJECTS_INTERFACE_OPTIONS; do
	    optname="${opt/--/}"
	    
	    if [[ " ${_OBJECTS_KEYS[@]} " =~ " $optname " ]]; then
		eval "function $opt {
                    if [[ \$# -eq 0 ]]; then
		      object.get_$optname
                    else
                      object.set_$optname \"\$@\"
                    fi
	        }"
	    else
		eval "function $opt {                     
                     object.$optname \"\$@\"
                }"
	    fi
	done
    }
    
    function objects.ui.disable {
	local opt=''
	for opt in $_OBJECTS_INTERFACE_OPTIONS; do
	    unset -f -- $opt
	done
    }
        
    function +object {

	declare -a args
	declare -a cargs
	declare remove arg next 
	
        # remove a previous type's interface
	remove="${_ObJeCtS_FOCUS}s.ui.disable"

	if [[ "$_ObJeCtS_FOCUS" != "object" ]]; then
	    if [[ "$_ObJeCtS_FOCUS" != '' ]]; then
		if $(type -t $remove &> /dev/null); then
		    $remove
		fi
	    fi
	    objects.ui.enable
	fi
	
        # set global current object type
	_ObJeCtS_FOCUS="object"
	
        # no arg -> return (setting focussed type is sideeffect)
	if [[ "$#" == "0" ]]; then
	    return 0
	fi

        # parse arguments and call ui functions	

	# check if the first argument is the object's name
	if [[ "$1" =~ ^[^\-] ]]; then 
	    # seek to the named object or create it
	    objects.seek "$1" || object.new "$1"
	    shift
	fi

	args=("$@")
	declare -i i=0
	for (( i=0; i<${#args[@]}; i++ )); do
	    arg="${args[i]}"
	    next="${args[i+1]}"

	    if [[ "$arg" =~ ^\-\- ]]; then		
                # get the command arguments
		cargs=()
		until [[ -z "$next" || "$next" =~ ^\-\- ]]; do	    
		    cargs[${#cargs[*]}]="$next"
		    i+=1; next="${args[i+1]}"
		done
		$arg "${cargs[@]}"
	    fi
	done
    }

    # completion
    function object.complete {

	local cur opts
	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	opts="$(objects.all)"

	if [[ ${cur} == * ]]; then
	    if [[ ${cur} =~ ^\- ]]; then
		cur=${cur//-/\\-}
		COMPREPLY=( $(compgen -W "${_OBJECTS_INTERFACE_OPTIONS}" ${cur}) )
	    else
		cur=${cur//-/\\-}
		COMPREPLY=( $(compgen -W "${opts} ${_OBJECTS_INTERFACE_OPTIONS}" ${cur}) )
	    fi
	fi
        return 0
    }
    complete -o default -F object.complete +object

    function object.complete_names {

	local cur="${COMP_WORDS[COMP_CWORD]}"
	local opts="$(objects.all)"

	COMPREPLY=( $(compgen -W "${opts}" ${cur}) )
        return 0
    }
    
    function +objects {
	if [[ $# -gt 0 ]]; then
	    local opt="$1"
	    shift	
	    opt="${opt/--/}"
	    if [[ "$(type -t objects.$opt 2> /dev/null)" == "function" ]]; then
		objects.$opt "$@"
	    fi
	fi
    }
    
    function objects.complete {

	local cur="${COMP_WORDS[COMP_CWORD]}"
	local opts="--list --code"

	COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    }
    complete -o default -F objects.complete +objects

fi

# "instance accessor methods" (generated by oBjEcTs) ###########


