# -*- shell-script -*-

################################################################################

bashrun_remote=$bashrun_data_home/$BASHRUN_MODE-remote
bashrun_remote_bindings=""

################################################################################

function §remote.run {

    local words cwd action command

    if [[ -f $bashrun_remote ]]; then
	
	words=($(<$bashrun_remote))
	cwd="${words[0]}"
	action="${words[1]}"
	command=${words[@]:2}

	§debug "action" -v "$action" "command" -v "$command" "cwd" -v "$cwd"

	if §actions.seek "$action"; then
	    cd "$cwd"
	    §engine.action "$action" 0 "$command"	
	    cd - &>/dev/null
	fi

	# we need to force a redisplay of the prompt
        # since readline didn't get an accept-line:
	kill -WINCH $$

	# remove command file
	rm $bashrun_remote

    else
	§debug warn "no command pending in" -v "$bashrun_remote"
	return 1
    fi
}

function §remote.interface.add {
    local type="$1"
    local action="$2"
    local keymap="$3"
    local char="$4"
    local keyseq="$5"

    [[ "$action" =~ ^(cycle-size|resize-|bashrun-|debug|reload|quit) ]] && return

    if [[ "$type" == "internal" ]]; then
	bashrun_remote_bindings+="bind -m $keymap -x \$'\"\C-z\\x$char\": §bashrun-remote $action'"

    elif [[ "$type" == "requested" ]]; then
	if [[ "$action" == "run" ]]; then
	    [[ "$keyseq" == '\C-m' ]] && keyseq='\e\C-m' 
	    [[ "$keyseq" == '\C-j' ]] && keyseq='\e\C-j' 
	fi
	if [[ "$action" == "term-run" ]]; then
	    [[ "$keyseq" == '\e\C-m' ]] && keyseq='\et'
	fi       

	bashrun_remote_bindings+="bind -m $keymap '\"$keyseq\"':$'\"\201\202\C-z\x$char\203\"'"
    fi
    bashrun_remote_bindings+=$'\n'
}

function §remote.interface.write {
    local file="$bashrun_cache_home/bashrun-remote.sh"
    echo $(cat <<EOF
    §bashrun-remote () { 
      bashrun do "\${1:-run}" "\$READLINE_LINE";
      READLINE_LINE="";
    };

    §bashrun-save-original-line () {
       bashrun_remote_command="\$READLINE_LINE";
       history -s "\$READLINE_LINE";
    };

    §bashrun-restore-original-line () {
      if [[ -n "\$bashrun_remote_command" ]]; then
        tput sc;
        tput cuu1;
        echo -n "\$bashrun_remote_command";
        tput rc;
      fi;
      kill -USR2 \$\$;
    };      

    trap 'bashrun_remote_command=""' SIGUSR2; 

    bind -x '"\201": §bashrun-save-original-line';
    bind '"\202": shell-expand-line';
    bind '"\203": accept-line';
    PS1="\$PS1\[\\\$(§bashrun-restore-original-line)\]"
EOF
) > "$file"

    echo "$bashrun_remote_bindings" >> "$file"
}