# -*- shell-script -*-

################################################################################
#
# Set up a "hash of hashes" and allow access to objects OOP-Style
#

# "class variables" ############################################################

_OBJECTS=()
_OBJECTS_KEYS=()
_OBJECTS_WIDTH=${#_OBJECTS_KEYS[@]}
_OBJECTS_POSITION=0
_OBJECTS_SIZE=0
_OBJECTS_MODIFIED=0

_OBJECTS_HAVE_INTERFACE=0
_OBJECTS_INTERFACE_METHODS=''
_OBJECTS_INTERFACE_OPTIONS=''
_OBJECTS_INTERFACE_OPTIONS_FOUND=()

# "class methods" (seeking to, matching and iterating objects) #################

function objects_seek { # args
    
    local matched=0
    local num_args=$#
    local start=0
    local saved=$_OBJECTS_POSITION
    local i=0

    if [[ num_args -eq 0 ]]; then
	return 0
    fi

    if [[ "$1" == "--next" ]]; then	
	(( start = _OBJECTS_POSITION + _OBJECTS_WIDTH ))
	if (( start > _OBJECTS_SIZE*_OBJECTS_WIDTH )); then
	    start=0
	fi
	shift
	(( num_args-=1 ))
    fi

    for ((i=$start; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	matched=0
	if [[ "${_OBJECTS[$i]}" == "$1" ]]; then
	    matched=1
	    if [[ $num_args -eq 2 ]]; then
		if [[ "${_OBJECTS[$i+1]}" == "$2" ]]; then
		    matched=1
		else
		    matched=0		    
		fi
	    fi		
	fi

	if [[ matched -eq 1 ]]; then
	    _OBJECTS_POSITION=$i
	    break
	fi	
    done
    
    if [[ matched -eq 0 ]]; then
	_OBJECTS_POSITION=$saved
	return 1
    else
	return 0
    fi
}

function objects_seek_start {
    _OBJECTS_POSITION=0
}

function objects_seek_end {
    (( _OBJECTS_POSITION = (_OBJECTS_SIZE-1) * _OBJECTS_WIDTH ))
}

function objects_next? {
    [[ $_OBJECTS_POSITION+$_OBJECTS_WIDTH -le ${#_OBJECTS[@]} ]] && return 0
    return 1
}

function objects_current {
    echo "${_OBJECTS[$_OBJECTS_POSITION]}"
}

function objects_next {
    (( _OBJECTS_POSITION += _OBJECTS_WIDTH ))
}

function objects_previous? {
    [[ $_OBJECTS_POSITION+1 -ge 0 ]] && return 0
    _OBJECTS_POSITION=0
    return 1
}

function objects_previous {
    (( _OBJECTS_POSITION -= _OBJECTS_WIDTH ))
}

function objects_select { # key value [which=0]-> "id1 id2..."

    local key=$1
    local wanted=$2
    local which=${3:-1} # 0: any, 1: all
    local value=''
    local ids=''
    local i=0
    local saved=${_OBJECTS[$_OBJECTS_POSITION]}

    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	_OBJECTS_POSITION=$i
	
	value=$(object_get $key)
	    if [[ "$value" == "$wanted" ]]; then
		ids="$ids ${_OBJECTS[$i]}"
		[[ which -eq 0 ]] && break
	    fi
    done
    objects_seek $saved

    echo "$ids"
}

function objects_modified? {

    [[ _OBJECTS_MODIFIED -eq 0 ]] && return 1
    [[ _OBJECTS_MODIFIED -eq 1 ]] && return 0
}

function objects_modified { # value
    _OBJECTS_MODIFIED=$1
}

function objects_list { # [ids]

    local saved=${_OBJECTS[$_OBJECTS_POSITION]}

    if [[ $1 != '' ]]; then
	for id in $@; do
	    if objects_seek $id; then
		object_list $id
	    fi
	done
    else
	objects_seek_start
	while objects_next?; do
	    object_list
	    objects_next
	done
    fi
    objects_seek $saved
}

function objects_all {
    
    local i=0
    local all=""
    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	all="$all ${_OBJECTS[$i]}"
    done
    echo "${all:1}"
}

# "instance methods" (always operate on the object at the current position) ####

function object__id {
    echo ${_OBJECTS[$_OBJECTS_POSITION]}
}

function object_new {
    local i
    
    for ((i=1; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	_OBJECTS[${#_OBJECTS[@]}]=${!i}
    done
    (( _OBJECTS_SIZE+=1 ))
    _OBJECTS_MODIFIED=1
    objects_seek $1
}

function object_get { # key -> "value"
    local key=$1
    local index=-1
    local i=0
 
    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then 
	echo "${_OBJECTS[$_OBJECTS_POSITION+$index]}"
    fi
}

function object_set { # key value

    local key=$1
    local value=$2
    local index=-1
    local i=0

    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then 
	_OBJECTS[$_OBJECTS_POSITION+$index]=$value
	_OBJECTS_MODIFIED=1
    fi
}

function object_code {
    
    local i=0;
    local args=''
    local here=$_OBJECTS_POSITION
    
    for ((i=this; i<=${#_OBJECTS_WIDTH}; i++)); do
	args="$args '${_OBJECTS[$i]}'"
    done
    _OBJECTS_POSITION=here

    echo "object_new $args"
}
    
function object_list {
    local key
    for key in ${_OBJECTS_KEYS[@]}; do
	echo "$key: $(object_get $key)"
    done;
    echo
}

################################################################################
## INTERFACE

if [[ _OBJECTS_HAVE_INTERFACE -eq 1 ]]; then

    function objects_interface_create {
	local opt=''
	for opt in $_OBJECTS_INTERFACE_OPTIONS; do
	    eval "function $opt {
		+object $opt \"\$@\"
	    }"
	done
    }
    
    function objects_interface_destroy {
	local opt=''
	for opt in $_OBJECTS_INTERFACE_OPTIONS; do
	    unset -f -- $opt
	done
    } 
    
    function +object {
	
	# remove a previous type's interface
	local destroy_interface="${_OBJ_CURRENT_TYPE}s_interface_destroy"
	if [[ "$_OBJ_CURRENT_TYPE" != "object" ]]; then
	    if $(type -t $destroy_interface &> /dev/null); then
		eval "$destroy_interface"
	    fi
	    objects_interface_create
	fi

	# set global current object type
	_OBJ_CURRENT_TYPE="object"

        # no arg -> return (setting global type is sideeffect)
	if [[ "$#" == "0" ]]; then
	    return 0
	fi

	# parse commandline arguments	
	local current=""
	local left=()
	local var=''
	local expect='arg' # optarg or arg       

	while [[ "$1" != '' ]]; do
	    
	    if [[ "$1" =~ ^-- ]]; then
		current="${1:2}"
		eval "_OBJECTS_INTERFACE_OPTION_$current=''"
		_OBJECTS_INTERFACE_OPTIONS_FOUND[${#_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}]="$current"		
		expect='optarg'
	    else
		if [[ "$expect" == "optarg" ]]; then
		    var="_OBJECTS_INTERFACE_OPTION_$current" 
		    eval "$var=\"${!var} $1\""
		else
		    left[${#left[@]}]="$1"
		fi
	    fi
	    shift
	done

	# trim leading whitespace from values
	local func=''
	for f in ${_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}; do
	    var="_OBJECTS_INTERFACE_OPTION_$f"
	    eval "$var=\"${!var:1}\""
	done
	
	# --new
	var="_OBJECTS_INTERFACE_OPTION_new"
	if defined? $var; then
	    if [[ ${!var} != '' ]]; then
		if ! objects_seek ${!var}; then
		    object_new "${!var}"
		else
		    echo "error: object exists: ${!var}"
		fi
	    else
		echo "--new: syntax error: name argument missing"
		return 1
	    fi
	fi

	# get objects       
	local which=""
	var="_OBJECTS_INTERFACE_OPTION_all"

	if defined? $var; then
	    which="$(objects_all)"
	else
	    if [[ "${#left[@]}" != "0" ]]; then
		which="${left[@]}"
	    else
		which="$(object__id)"
	    fi
	fi
	
	local id=''
	for id in $which; do

	    # seek object
	    if ! objects_seek $id; then
		echo "warning: no such object: $id"
		echo "         use '+object --new $id' to create it"
		continue
	    fi

	    local i=0
	    local key=''
	    local var=''
	    local val=''
	    
	    # --code
	    var="_OBJECTS_INTERFACE_OPTION_code"
	    if defined? $var; then	    
		object_code
	    fi
	    
	    # call methods
	    local method=''
	    for method in $_OBJECTS_INTERFACE_METHODS; do
		var="_OBJECTS_INTERFACE_OPTION_$method"
		if defined? $var; then
		    if $(type -t object_$method &> /dev/null); then
			eval "object_$method \"${!var}\""
		    else
			echo "method object_$method not implemented."
		    fi
		fi
	    done
	    
	    # get/set attributes
	    for ((i=0; i<${#_OBJECTS_KEYS[@]}; i++)); do
		key=${_OBJECTS_KEYS[$i]}
		var="_OBJECTS_INTERFACE_OPTION_$key"
		
		if defined? $var; then
		    val="${!var}"
		    if [[ "$val" == '' ]]; then
			echo $(object_get $key)
		    else
			object_set "$key" "$val"
		    fi
		fi
	    done	
	done

        # cleanup all _OBJECTS_INTERFACE_OPTION_* vars

	local f=''
	for f in ${_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}; do
	    var="_OBJECTS_INTERFACE_OPTION_$f"
	    unset $var
	done
	_OBJECTS_INTERFACE_OPTIONS_FOUND=()
    }

    function +ls {
	${_OBJ_CURRENT_TYPE}s_list 
    }
    
    # completion
    function objects_complete {

	local cur prev opts
	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	prev="${COMP_WORDS[COMP_CWORD-1]}"
	opts="$(objects_all)"

	if [[ ${cur} == * ]]; then
	    if [[ ${cur} =~ ^\- ]]; then
		cur=${cur//-/\\-}
		COMPREPLY=( $(compgen -W "${_OBJECTS_INTERFACE_OPTIONS}" ${cur}) )
	    else
		cur=${cur//-/\\-}
		COMPREPLY=( $(compgen -W "${opts} ${_OBJECTS_INTERFACE_OPTIONS}" ${cur}) )
	    fi
	fi
        return 0
    }

    complete -F objects_complete +object
    
fi # end _OBJECTS_HAVE_INTERFACE

# "instance accessor methods" (generated by object) ###########

