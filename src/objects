# -*- shell-script -*-

################################################################################
#
# Set up a "hash of hashes" and allow access to objects OOP-Style
#

# "class variables" ############################################################

_OBJECTS=()
_OBJECTS_KEYS=()
_OBJECTS_WIDTH=${#_OBJECTS_KEYS[@]}
_OBJECTS_POSITION=0
_OBJECTS_SIZE=0
_OBJECTS_MODIFIED=0
_OBJECTS_INTERFACE=()
_OBJECTS_HAVE_INTERFACE=1
_OBJECTS_INTERFACE_OPTIONS_FOUND=()

# "class methods" (seeking to, matching and iterating objects) #################

function objects_seek { # args
    
    local matched=0
    local num_args=$#
    local start=0
    local saved=$_OBJECTS_POSITION
    local i=0

    if [[ num_args -eq 0 ]]; then
	return 0
    fi

    if [[ "$1" == "--next" ]]; then	
	(( start = _OBJECTS_POSITION + _OBJECTS_WIDTH ))
	if (( start > _OBJECTS_SIZE*_OBJECTS_WIDTH )); then
	    start=0
	fi
	shift
	(( num_args-=1 ))
    fi

    for ((i=$start; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	matched=0
	if [[ "${_OBJECTS[$i]}" == "$1" ]]; then
	    matched=1
	    if [[ $num_args -eq 2 ]]; then
		if [[ "${_OBJECTS[$i+1]}" == "$2" ]]; then
		    matched=1
		else
		    matched=0		    
		fi
	    fi		
	fi

	if [[ matched -eq 1 ]]; then
	    _OBJECTS_POSITION=$i
	    break
	fi	
    done
    
    if [[ matched -eq 0 ]]; then
	_OBJECTS_POSITION=$saved
	return 1
    else
	return 0
    fi
}

function objects_seek_start {
    _OBJECTS_POSITION=0
}

function objects_seek_end {
    (( _OBJECTS_POSITION = (_OBJECTS_SIZE-1) * _OBJECTS_WIDTH ))
}

function objects_have_next {
    [[ $_OBJECTS_POSITION+$_OBJECTS_WIDTH -le ${#_OBJECTS[@]} ]] && return 0
    return 1
}

function objects_current {
    echo "${_OBJECTS[$_OBJECTS_POSITION]}"
}

function objects_next {
    (( _OBJECTS_POSITION += _OBJECTS_WIDTH ))
}

function objects_have_previous {
    [[ $_OBJECTS_POSITION+1 -ge 0 ]] && return 0
    _OBJECTS_POSITION=0
    return 1
}

function objects_previous {
    (( _OBJECTS_POSITION -= _OBJECTS_WIDTH ))
}

function objects_select { # key value [which=0]-> "id1 id2..."

    local key=$1
    local wanted=$2
    local which=${3:-1} # 0: any, 1: all
    local value=''
    local ids=''
    local i=0
    local saved=${_OBJECTS[$_OBJECTS_POSITION]}

    for ((i=0; i<=${#_OBJECTS[@]}; i+=${#_OBJECTS_KEYS[@]})); do
	_OBJECTS_POSITION=$i
	
	value=$(object_get $key)
	    if [[ "$value" == "$wanted" ]]; then
		ids="$ids ${_OBJECTS[$i]}"
		[[ which -eq 0 ]] && break
	    fi
    done
    objects_seek $saved

    echo "$ids"
}

function objects_modified? {

    [[ _OBJECTS_MODIFIED -eq 0 ]] && return 1
    [[ _OBJECTS_MODIFIED -eq 1 ]] && return 0
}

function objects_modified { # value
    _OBJECTS_MODIFIED=$1
}

function objects_list { # [ids]

    local saved=${_OBJECTS[$_OBJECTS_POSITION]}

    if [[ $1 != '' ]]; then
	for id in $@; do
	    if objects_seek $id; then
		object_list $id
	    fi
	done
    else
	objects_seek_start
	while objects_have_next; do
	    object_list
	    objects_next
	done
    fi
    objects_seek $saved
}

# "instance methods" (always operate on the object at the current position) ####

function object_new {
    local i
    
    for ((i=1; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	_OBJECTS[${#_OBJECTS[@]}]=${!i}
    done
    (( _OBJECTS_SIZE+=1 ))
    _OBJECTS_MODIFIED=1
    objects_seek $1
}

function object_get { # key -> "value"
    local key=$1
    local index=-1
    local i=0
 
    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then 
	echo "${_OBJECTS[$_OBJECTS_POSITION+$index]}"
    fi
}

function object_set { # key value

    local key=$1
    local value=$2
    local index=-1
    local i=0

    for ((i=0; i<=${#_OBJECTS_KEYS[@]}; i++)); do
	if [[ ${_OBJECTS_KEYS[$i]} == $key ]]; then
	    index=$i
	    break
	fi
    done

    if [[ index -ge 0 ]]; then 
	_OBJECTS[$_OBJECTS_POSITION+$index]=$value
	_OBJECTS_MODIFIED=1
    fi
}

function object_code {
    
    local i=0;
    local args=''
    local here=$_OBJECTS_POSITION
    
    for ((i=this; i<=${#_OBJECTS_WIDTH}; i++)); do
	args="$args '${_OBJECTS[$i]}'"
    done
    _OBJECTS_POSITION=here

    echo "object_new $args"
}
    
function object_list {
    local key
    for key in ${_OBJECTS_KEYS[@]}; do
	echo "$key: $(object_get $key)"
    done;
    echo
}

################################################################################
## INTERFACE

if [[ _OBJECTS_HAVE_INTERFACE -eq 1 ]]; then

    function objects_interface_clear_options {

        # cleanup all _OBJECTS_INTERFACE_OPTION_* vars

	local f=''
	local var=''
	for f in ${_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}; do
	    var="_OBJECTS_INTERFACE_OPTION_$f"
	    unset $var
	done
	_OBJECTS_INTERFACE_OPTIONS_FOUND=()
    }
    
    function +object {
	
        # no arg -> set mode
        
	if [[ "$#" == "0" ]]; then
	    echo "TODO: set global mode ('cwd')"
	    return 0
	fi

	objects_interface_clear_options

        # non-option arg 'id' -> seek id
        # + --<id_key_name> (reader for prop)
        # + --<methods>
	
	local current=""
	local left=()
	local expect='arg' # optarg or arg
	
	while [[ "$1" != '' ]]; do
	    
	    if [[ "$1" =~ ^-- ]]; then
		current="${1:2}"
		eval "_OBJECTS_INTERFACE_OPTION_$current=''"
		_OBJECTS_INTERFACE_OPTIONS_FOUND[${#_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}]="$current"		
		expect='optarg'
	    else
		if [[ "$expect" == "optarg" ]]; then
		    eval "_OBJECTS_INTERFACE_OPTION_$current=\"$1\""
		    expect='arg'
		else
		    left[${#left[@]}]="$1"
		fi
	    fi
	    shift
	done
	
        # # debug...
	# local found=''
	# for found in ${_OBJECTS_INTERFACE_OPTIONS_FOUND[@]}; do
	#     var="_OBJECTS_INTERFACE_OPTION_$found"
	#     echo "$found: ${!var}"
	# done

	# check for name in leftover args and seek
	if [[ "${#left[@]}" != '0' ]]; then
	    if actions_seek ${left[0]}; then
		return 0
	    else
		echo "error: no such action: ${left[0]}"
		return 1
	    fi
	fi

        # process...
	
	local i=0
	local key=''
	local var=''
	local val=''

	# --add or --new

	local func
	for func in "new" "add"; do
	    var="_OBJECTS_INTERFACE_OPTION_$func"
	    if defined? $var; then
		if [[ ${!var} != '' ]]; then
		    action_new "${!var}"
		else
		    echo "+object: syntax error: --$func requires a name argument"
		    return 1
		fi
	    fi
	done

	# get/set attributes
	for ((i=0; i<${#_OBJECTS_KEYS[@]}; i++)); do
	    key=${_OBJECTS_KEYS[$i]}
	    var="_OBJECTS_INTERFACE_OPTION_$key"

	    if defined? $var; then
		val="${!var}"
		if [[ "$val" == '' ]]; then
		    echo $(object_get $key)
		else
		    object_set "$key" "$val"
		fi
	    fi
	done	

	objects_interface_create
    }

    function objects_interface_create {
	:
    }
    
    function objects_interface_destroy {
	:
    }  
fi

function defined? {
    [[ ${!1-X} == ${!1-Y} ]]
}

# "instance accessor methods" (generated by object) ###########

