# -*- shell-script -*-

################################################################################

_OBJECTS_CACHE_HOME='/tmp'
_OBJECTS_DATA_HOME='/tmp'
_OBJECTS_NAMESPACE='boop'
_OBJECTS_SITE="."

_OBJECTS_TYPES=''
_OBJECTS_FOCUS=''

function §objects.site {
    
    local site="$1"
    if [[ "$site" == '' ]]; then
	echo "$_OBJECTS_SITE"
    else
	_OBJECTS_SITE="$site"
    fi
}

function §objects.cache_home {
    
    local cache_home=$1
    if [[ "$cache_home" == '' ]]; then
	echo "$_OBJECTS_CACHE_HOME"
    else
	_OBJECTS_CACHE_HOME="$cache_home"
    fi
}

function §objects.data_home {
    
    local data_home=$1
    if [[ "$data_home" == '' ]]; then
	echo "$_OBJECTS_DATA_HOME"
    else
	_OBJECTS_DATA_HOME="$data_home"
    fi
}

function §objects.namespace {
    
    local namespace=$1
    if [[ "$namespace" == '' ]]; then
	echo "$_OBJECTS_NAMESPACE"
    else
	_OBJECTS_NAMESPACE="$namespace"
    fi
}

function §objects.types {    
    echo " $_OBJECTS_TYPES "
}

function §objects.focus {
    
    local type=$1
    if [[ "$type" == '' ]]; then
	echo "$_OBJECTS_FOCUS"
    else
	_OBJECTS_FOCUS="$type"
    fi
}

function §objects.seek_start {
    local type=""
    for type in $_OBJECTS_TYPES; do
	${type}s.seek_start
    done    
}

function §class {

    # create object from 'objects' template

    local name=$1
    local keys=$2
    local key=''
    local clean_keys=""
    local methods="nil"
    local have_interface=0
    
    # register object type
    _OBJECTS_TYPES="$_OBJECTS_TYPES $name"
    if [[ "${_OBJECTS_TYPES:0:1}" == ' ' ]]; then
	_OBJECTS_TYPES="${_OBJECTS_TYPES:1}"
    fi

    # interface and additional interfaced methods
    if [[ "$#" == "3" ]]; then 
	methods=${3}
    fi

    for key in $keys; do
	if [[ "$key" =~ (.+?):(.+) ]]; then
	    key=${BASH_REMATCH[1]}
	fi
	clean_keys="$clean_keys $key"
    done

    if [[ "$methods" != 'nil' ]]; then

	local interface=(new code $clean_keys $methods)
	have_interface=1

        # prepare interface options (prefix with --)
	local i=0
	for ((i=0; i<${#interface[@]}; i++)); do
	    interface[$i]="--${interface[$i]}"
	done
	interface="${interface[@]}"
    fi

    local tmpfile=$_OBJECTS_CACHE_HOME/$name.bash

    if [[ -f $tmpfile ]]; then
	source $tmpfile
	return 0
    fi

    local NAME="$(§objects.namespace)_$name"
    NAME=${NAME//§/}
    NAME=$(echo $NAME | tr "[:lower:]" "[:upper:]")

    local plusname=${name//§/+}

    cat $_OBJECTS_SITE/object | \
	sed "s|_OBJECTS_KEYS=()|_OBJECTS_KEYS=($clean_keys)|" | \
	sed "s|_OBJECTS_INTERFACE_OPTIONS=''|_OBJECTS_INTERFACE_OPTIONS='$interface' |" | \
	sed "s|_OBJECTS_HAVE_INTERFACE=0|_OBJECTS_HAVE_INTERFACE=$have_interface|" | \
	sed "s|_OBJECTS_INTERFACE_METHODS=''|_OBJECTS_INTERFACE_METHODS='$methods'|" | \
	sed "s|object|$name|g;s|+$name|$plusname|g;s|OBJECT|$NAME|g;" | \
	sed "s|ObJeCt|OBJECT|g;s|oBjEcT|§object|g" \
	> $tmpfile

    local i=0
    local access='rw'
    for key in $keys; do
	if [[ "$key" =~ (.+?):(.*) ]]; then
	    key=${BASH_REMATCH[1]}
	    access=${BASH_REMATCH[2]}
	    [[ "$access" == "b" ]] && access="rwb"
	else
	    access="rw"
	fi

	if [[ "$access" =~ r ]]; then
      	    §object.create_reader $name $NAME $key $i
	fi
	if [[ "$access" =~ w ]]; then
	    if [[ "$access" =~ b ]]; then
		§object.create_bool_writer $name $NAME $key $i
	    else
		§object.create_writer $name $NAME $key $i
	    fi
	fi
	let i++
    done
    
    source $tmpfile

    return 0
}

function §objects.list {
    ${_OBJECTS_FOCUS}s.list 
}

function §objects.dump {
    local type=""
    for type in $_OBJECTS_TYPES; do
	eval "${type}s.dump"
    done
}

function §objects.restore {
    local type=""
    for type in $_OBJECTS_TYPES; do
	eval "${type}s.restore"
    done
}

function §objects.clear {
    local type=""
    for type in $_OBJECTS_TYPES; do
	eval "${type}s.clear"
    done
}

function §object.create_reader {
    local name=$1
    local NAME=$2
    local key=$3
    local field=$4
    local tmpfile=$_OBJECTS_CACHE_HOME/$name.bash

    echo $(cat <<EOF

function ${name}.get_${key} {
    echo "\${_${NAME}S[\$_${NAME}S_POSITION+$field]}";
}
EOF
    ) >> $tmpfile
}

function §object.create_writer {
    local name=$1
    local NAME=$2
    local key=$3
    local field=$4
    local tmpfile=$_OBJECTS_CACHE_HOME/$name.bash

    echo $(cat <<EOF

function ${name}.set_${key} {
    _${NAME}S[\$_${NAME}S_POSITION+$field]=\$1;
    _${NAME}S_MODIFIED=1;
}
EOF
    ) >> $tmpfile
}

function §object.create_bool_writer {
    local name=$1
    local NAME=$2
    local key=$3
    local field=$4
    local tmpfile=$_OBJECTS_CACHE_HOME/$name.bash

    echo $(cat <<EOF

function ${name}.set_${key} {

     local input="\$1";
     local value=0;

     [[ -n "\$input" ]] && value=1;
     [[ "\$input" =~ ^([Yy]es|[Tt]rue|1)\$ ]] && value=1;
     [[ "\$input" =~ ^([Nn]o|[Ff]alse|0)\$ ]] && value=0;

    _${NAME}S[\$_${NAME}S_POSITION+$field]=\$value;
    _${NAME}S_MODIFIED=1;
}
EOF
    ) >> $tmpfile
}
