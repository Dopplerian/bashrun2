# -*- shell-script -*-

################################################################################

§class "binding" --properties "keyseq" "keymap" "action" \
                              "is_bound:b" "readline"  

§class "internal" --properties "action" "keymap" "char" "readline"

§class "keyname" --properties "keyseq" "name"                             

bind '"\C-x00": accept-line'

bashrun_bindings_next_char=20 
bashrun_bindings_blacklist=" 34 39 127 "                         

bashrun_keymap='emacs' # will be initialized in engine.init

§function.clone "§bindings.init" "§bindings._init"
§function.clone "§bindings.dump" "§bindings._dump"
§function.clone "§internals.dump" "§internals._dump"
§function.clone "§keynames.dump" "§keynames._dump"

################################################################################

function §bindings.init {
    local file="$bashrun_cache_home/keybindings"
    [[ -f "$file" ]] && rm "$file"

    §bindings._init
}

function §binding.bound? {
    [[ "$(§binding.get_is_bound)" == '1' ]]
}

function §binding.get_keyname {
    local keyseq="$(§binding.get_keyseq)"
    if §keynames.seek "$keyseq"; then
	printf '%s' "$(§keyname.get_name)"
    else
	printf '%s' "$(§ks2kn "$keyseq")"
    fi
}

function §emacs-mode.dump () {
    §bindings.dump "$@"
}

function §vi-mode.dump () {
    §bindings.dump "$@"
}

function set {
    builtin set "$@"
    if [[ "$1" == "-o" && "$2" =~ (emacs|vi) ]]; then
	local mode="${BASH_REMATCH[1]}-mode"
	local feedback=$bashrun_feedback
	bashrun_feedback=0

	§bindings.clear
	§internals.clear
	§keynames.clear
	§configs.clear

	§configs.restore_core "$mode" &>/dev/null
	§configs.collect_user_configs "$mode"

	§configs.seek "$mode" && §config.restore 

	§readline.get_settings

	bashrun_feedback=$feedback
    fi
}

function §bindings.dump {

    local file="$(§objects.data_home)/${1:-bindings.dump}"
    local remote_bindings="$bashrun_cache_home/remote-bindings.bash"

    [[ -f "$remote_bindings" ]] && rm "$remote_bindings"

    §bindings._dump "${1:-bindings.dump}"

    printf '%s\n' "bashrun_bindings_next_char=$bashrun_bindings_next_char" >> $file

    §internals.dump "${1:-bindings.dump}" append
    §keynames.dump "${1:-bindings.dump}" append

    local saved=$(§binding.get_keyseq)

    §bindings.seek_start
    while §bindings.next?; do
	if §binding.bound?; then
	    # dump the bashrun binding
	    printf '%s\n' "bind $(§binding.get_readline)" >> $file

	    # create the remote interface binding
	    local keyseq="$(§binding.get_keyseq)"
	    local keymap="$(§binding.get_keymap)"
	    local action="$(§binding.get_action)"
	    
	    §internals.seek "$action" "$keymap"
	    local char="$(§internal.get_char)"
	    
	    §remote.interface.bind "internal" \
		"$action" "$keymap" "$char" "$keyseq"
	    §remote.interface.bind "requested" \
		"$action" "$keymap" "$char" "$keyseq"	
	fi
	§bindings.next
    done
    §bindings.seek $saved
}

function §internals.dump {

    local file="$(§objects.data_home)/${1:-internals.dump}"

    §internals._dump "${1:-internals.dump}" append

    local saved=$(§internal.get_action)

    §internals.seek_start
    while §internals.next?; do
	printf '%s\n' "bind $(§internal.get_readline)" >> $file
	§internals.next
    done    
    §internals.seek $saved
}

function §keynames.dump {

    §keynames._dump "${1:-§keynames.dump}" append

}

################################################################################
