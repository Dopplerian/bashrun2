# -*- shell-script -*-

################################################################################

BASHRUN_COMMAND=''
BASHRUN_COMMAND_LINE=''
BASHRUN_COMMAND_WORD=''

function bashrun_command_unquote {

    command="$BASHRUN_COMMAND"
    # unquote quoted &;|
    command=${command//\\&/&}
    command=${command//\\|/|}
    command=${command// \\; /;}
    command=${command//&&/ && }
    command=${command//||/ || }

    BASHRUN_COMMAND=$command
}

function bashrun_command_get_line {
    # updates BASHRUN_COMMAND_LINE to contain the complete and
    # verbatim line entered by the user.
    
    local command_line=''
    local histtimeformat=$HISTTIMEFORMAT
    unset HISTTIMEFORMAT

    [[ $(history 1) =~ \ +[0-9]+?\ +(.+?) ]]
    BASHRUN_COMMAND_LINE=${BASH_REMATCH[1]}
    
    if [[ "$histtimeformat" != "" ]]; then
	HISTTIMEFORMAT=$histtimeformat
    fi
    echo "$BASHRUN_COMMAND_LINE"
}

function bashrun_command_get_word {

    # updates BASHRUN_COMMAND_WORD to contain the first word of the
    # current command.

    local word="$BASHRUN_COMMAND"

    word=${word//\\ /<qspace>}
    if [[ "$word" =~ ([^\ \&\;\|]+) ]]; then
	word=${BASH_REMATCH[1]}
    fi
    word=${word//<qspace>/\\ }
    word=$(echo $word | sed -r "s/^ +//;s/ +$//")
    word=$(echo $word | sed -r "s/^\\(+//;s/\\)+$//")

    BASHRUN_COMMAND_WORD="$word"
}

function bashrun_command_word_executable? {
    
    # check if BASHRUN_COMMAND_WORD is executable

    bashrun_command_get_word

    local word="$BASHRUN_COMMAND_WORD"
    local type=`type -t $word`

    if [[ "$type" =~ (alias|keyword|builtin) ]]; then
	bashrun_debug "$word-> $type -> yes"
	return 0
    fi

    if [[ "$type" == "function" ]]; then
	if bashrun_command_word_bookmark?; then
	    bashrun_debug "$word -> bookmark -> no"
	    return 1
	else
	    bashrun_debug "$word -> $type -> yes"
	    return 0
	fi
    fi

    if [[ "$type" == "file" ]]; then
	if [[ `which $word 2> /dev/null` ]]; then
	    bashrun_debug "which: `which $word` -> yes"
	    return 0
	fi
	if [[ -x $word ]]; then
	    bashrun_debug "+x $word -> yes"
	    return 0
	fi
    fi

    bashrun_debug "$word -> no"
    return 1
}

function bashrun_command_word_buitlin? {

    # check if BASHRUN_COMMAND_WORD is a shell builtin command

    bashrun_command_get_word
    local word="$BASHRUN_COMMAND_WORD"

    local result=`type $word 2>&1 | head -n1`

    if [[ "$result" =~ builtin ]]; then
	bashrun_debug "$word: yes"
	return 0
    fi
    bashrun_debug "$word: no"
    return 1
}

function bashrun_command_word_bookmark? {

    local bookmark=''
    for bookmark in ${_BOOKMARKS[@]}; do
	[[ "$BASHRUN_COMMAND_WORD" == "$bookmark" ]] && return 0
    done;
    return 1
}

function bashrun_command_wrap_in_su {

    local user=${1:-root}

    # COMMAND goes into su -c '' -> escape single quotes
    BASHRUN_COMMAND=${BASHRUN_COMMAND//\'/\\\'}

    # run the command itself in the background
    if [[ ! "$BASHRUN_COMMAND" =~ \&\ *$ ]]; then
	BASHRUN_COMMAND="su $user -c '$BASHRUN_COMMAND &> /dev/null &'"
    fi
    # run the su part (passwort entry) in foreground 
    BASHRUN_EXECMODE="" 
    bashrun_debug "$BASHRUN_COMMAND"
}

function bashrun_command_wrap_in_terminal {

    local xterm=''

    bashrun_command_get_word

    if [[ "$BASHRUN_COMMAND_WORD" == "xterm" ]]; then
	bashrun_debug "already in terminal"
	return 1
    fi

    # COMMAND goes into xterm -e "" -> escape double quotes
    BASHRUN_COMMAND=${BASHRUN_COMMAND//\"/\\\"}

    # command template
    xterm="xterm -e \"\$1\""
    
    # insert
    BASHRUN_COMMAND=${xterm/\$1/$BASHRUN_COMMAND}

    bashrun_debug "$BASHRUN_COMMAND"

    return 0
}

function bashrun_command_append_pager {
    BASHRUN_COMMAND="$BASHRUN_COMMAND | ${PAGER:-less -f}"
}
