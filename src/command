# -*- shell-script -*-

################################################################################

BASHRUN_COMMAND=''
BASHRUN_COMMAND_LINE=''
BASHRUN_COMMAND_WORD=''

function §command.unquote {

    command="$BASHRUN_COMMAND"

    # unquote quoted &;|
    command=${command//\\&/&}
    command=${command//\\|/|}
    command=${command//\\;/;}
    command=${command//&&/ && }
    command=${command//||/ || }

    BASHRUN_COMMAND=$command
}

function §command.get_line {
    # updates BASHRUN_COMMAND_LINE to contain the complete and
    # verbatim line entered by the user.
    
    local command_line=''
    local histtimeformat=$HISTTIMEFORMAT
    unset HISTTIMEFORMAT

    [[ $(history 1) =~ \ +[0-9]+?\ +(.+?) ]]
    BASHRUN_COMMAND_LINE=${BASH_REMATCH[1]}
    
    if [[ "$histtimeformat" != "" ]]; then
	HISTTIMEFORMAT=$histtimeformat
    fi
    echo "$BASHRUN_COMMAND_LINE"
}

function §command.get_word {

    # updates BASHRUN_COMMAND_WORD to contain the first word of the
    # current command that does not contain a '='.

    local word=""

    for word in $BASHRUN_COMMAND; do
	[[ ! "$word" =~ = ]] && break
    done 
    BASHRUN_COMMAND_WORD="$word"
}

function §command.executable? {
    
    # check if BASHRUN_COMMAND_WORD is executable

    §command.get_word

    local word="$BASHRUN_COMMAND_WORD"
    local type=`type -t $word`

    if [[ "$type" =~ (alias|keyword|builtin) ]]; then
	§debug -v "$word" "->" -v "$type" "->" -g "yes"
	return 0
    fi

    if [[ "$type" == "function" ]]; then
	if §function.exported? $word; then
	    §debug -v "$word" "->" -v "exported $type" "->" -g "yes"
	    return 0
	else	    
	    §debug -v "$word" "->" -v "$type" "->" -r "no"
	    return 1
	fi
    fi

    if [[ "$type" == "file" ]]; then
	if type -p $word &> /dev/null; then
	    §debug -v "$word" "->" -v "$type" "-> type -p $word ? ->" -g "yes"
	    return 0
	fi
	if [[ -x $word ]]; then
	    §debug -v "$word" "->" -v "$type" "-> +x $word ? ->" -g "yes"
	    return 0
	fi
    fi

    §debug -v "$word" "->" -r "no"
    return 1
}

function §command.builtin? {

    # check if BASHRUN_COMMAND_WORD is a shell builtin command

    §command.get_word
    local word="$BASHRUN_COMMAND_WORD"

    if [[ "$(type -t $word)" == "builtin" ]]; then
	§debug -v "$word" "->" -g yes
	return 0
    fi
    §debug -v "$word" "->" -r no
    return 1
}

function §command.bookmark? {

    if §bookmarks.seek "$1"; then
	return 0
    fi
    return 1
}

function §command.add_su {

    local user=${1:-root}

    # don't wrap in su -c '' twice...
    if [[ "$BASHRUN_COMMAND" =~ ^su\  ]]; then
	§debug "already using su"
	return 0
    fi

    # prompt for username
    if [[ "$user" == "--prompt" ]]; then
	until [[ -n "$user" && "$user" != "--prompt" ]]; do
	    tput el
	    tput cr
	    echo -ne 'Username: '
	    read user
	done
    fi

    # run the command itself in the background
    BASHRUN_COMMAND="$BASHRUN_COMMAND &> /dev/null &"

    # quote the command
    printf -v BASHRUN_COMMAND %q "$BASHRUN_COMMAND"

    # prefix with su command
    BASHRUN_COMMAND="su $user -c $BASHRUN_COMMAND"

    # run the su command in foreground for password entry
    BASHRUN_EXECMODE="" 
    §debug "$BASHRUN_COMMAND"
}

function §command.add_terminal {

    §command.get_word
    local terminal=""
    local terminal_command=""
    local method=""

    for terminal in $(§terminals.used); do
	if [[ "$BASHRUN_COMMAND_WORD" == "$terminal" ]]; then
	    §debug "already using" -v "$terminal"
	    return 1
	fi
    done

    if [[ $# -eq 1 ]]; then
	if ! §terminals.seek "$1"; then
	    terminals.seek 'default'
	fi
    fi

    if [[ "$(§terminal.get_name)" == "bashrun" ]]; then
	§terminals.seek 'default'
    fi

    # get the terminal command
    terminal_command="$(§terminal.get_command)"

    # %* insert command split into words
    # %@ insert command as a single word (one level of quoting)
    # %@@, %@@@, ... add two, three, etc. levels of quoting
    if [[ "$terminal_command" =~ [^\\]%((@|\*)+) ]]; then
	method="${BASH_REMATCH[1]}"
	
	if [[ "$method" =~ @ ]]; then
		§quote ${#method} BASHRUN_COMMAND
	fi

	# insert command into terminal command 
	BASHRUN_COMMAND="$(§replace "$terminal_command" "%$method" "$BASHRUN_COMMAND")"

    else
	# append command to terminal command
	BASHRUN_COMMAND="$(§terminal.get_command) $BASHRUN_COMMAND"
    fi
    §debug "$BASHRUN_COMMAND"

    return 0
}

function §command.add_hold {

    local seconds=${1:-0}
    local method='read -n1'
    [[ seconds -gt 0 ]] && method="sleep $seconds"

    if [[ "$BASHRUN_COMMAND" =~ ^\(.+?\)$ ]]; then
	BASHRUN_COMMAND=${BASH_REMATCH[1]}
    fi
    
    if [[ ! "$BASHRUN_COMMAND" =~ \#__HOLD__$ ]]; then
	BASHRUN_COMMAND="tput civis; (${BASHRUN_COMMAND}); $method #__HOLD__";
	§debug "$BASHRUN_COMMAND"
    else
	§debug "already using hold:" -v "$BASHRUN_COMMAND"
    fi
}

function §command.add_pager {
    if [[ ! "$BASHRUN_COMMAND" =~ \#__PAGER__$ ]]; then
	BASHRUN_COMMAND="$BASHRUN_COMMAND | ${PAGER} #__PAGER__"
	§debug "$BASHRUN_COMMAND"
    else
	§debug "already using pager:" -v "$BASHRUN_COMMAND"
    fi
}
