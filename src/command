# -*- shell-script -*-

################################################################################

BASHRUN_COMMAND=''
BASHRUN_COMMAND_LINE=''
BASHRUN_COMMAND_WORD=''

function bashrun.command.unquote {

    command="$BASHRUN_COMMAND"
    # unquote quoted &;|
    command=${command//\\&/&}
    command=${command//\\|/|}
    command=${command// \\; /;}
    command=${command//&&/ && }
    command=${command//||/ || }

    BASHRUN_COMMAND=$command
}

function bashrun.command.get_line {
    # updates BASHRUN_COMMAND_LINE to contain the complete and
    # verbatim line entered by the user.
    
    local command_line=''
    local histtimeformat=$HISTTIMEFORMAT
    unset HISTTIMEFORMAT

    [[ $(history 1) =~ \ +[0-9]+?\ +(.+?) ]]
    BASHRUN_COMMAND_LINE=${BASH_REMATCH[1]}
    
    if [[ "$histtimeformat" != "" ]]; then
	HISTTIMEFORMAT=$histtimeformat
    fi
    echo "$BASHRUN_COMMAND_LINE"
}

function bashrun.command.get_word {

    # updates BASHRUN_COMMAND_WORD to contain the first word of the
    # current command.

    local word="$BASHRUN_COMMAND"

    word=${word//\\ /<qspace>}
    if [[ "$word" =~ ([^\ \&\;\|]+) ]]; then
	word=${BASH_REMATCH[1]}
    fi
    word=${word//<qspace>/\\ }
    word=$(echo $word | sed -r "s/^ +//;s/ +$//")
    word=$(echo $word | sed -r "s/^\\(+//;s/\\)+$//")

    BASHRUN_COMMAND_WORD="$word"
}

function bashrun.command.executable? {
    
    # check if BASHRUN_COMMAND_WORD is executable

    bashrun.command.get_word

    local word="$BASHRUN_COMMAND_WORD"
    local type=`type -t $word`

    if [[ "$type" =~ (alias|keyword|builtin) ]]; then
	bashrun.debug "$word-> $type -> yes"
	return 0
    fi

    if [[ "$type" == "function" ]]; then
	if bashrun.command.bookmark?; then
	    bashrun.debug "$word -> bookmark -> no"
	    return 1
	else
	    bashrun.debug "$word -> $type -> yes"
	    return 0
	fi
    fi

    if [[ "$type" == "file" ]]; then
	if [[ `which $word 2> /dev/null` ]]; then
	    bashrun.debug "which: `which $word` -> yes"
	    return 0
	fi
	if [[ -x $word ]]; then
	    bashrun.debug "+x $word -> yes"
	    return 0
	fi
    fi

    bashrun.debug "$word -> no"
    return 1
}

function bashrun.command.builtin? {

    # check if BASHRUN_COMMAND_WORD is a shell builtin command

    bashrun.command.get_word
    local word="$BASHRUN_COMMAND_WORD"

    local result=`type $word 2>&1 | head -n1`

    if [[ "$result" =~ builtin ]]; then
	bashrun.debug "$word: yes"
	return 0
    fi
    bashrun.debug "$word: no"
    return 1
}

function bashrun.command.bookmark? {

    if bookmarks.seek "$1"; then
	return 0
    fi
    return 1
}

function bashrun.command.add_su {

    local user=${1:-root}

    # COMMAND goes into su -c '' -> escape single quotes
    BASHRUN_COMMAND=${BASHRUN_COMMAND//\'/\\\'}

    # run the command itself in the background
    if [[ ! "$BASHRUN_COMMAND" =~ \&\ *$ ]]; then
	BASHRUN_COMMAND="su $user -c '$BASHRUN_COMMAND &> /dev/null &'"
    fi
    # run the su part (passwort entry) in foreground 
    BASHRUN_EXECMODE="" 
    bashrun.debug "$BASHRUN_COMMAND"
}

function bashrun.command.add_terminal {

    local xterm=''

    bashrun.command.get_word

    if [[ "$BASHRUN_COMMAND_WORD" == "xterm" ]]; then
	bashrun.debug "already in terminal"
	return 1
    fi

    # COMMAND goes into xterm -e "" -> escape double quotes
    BASHRUN_COMMAND=${BASHRUN_COMMAND//\"/\\\"}

    # command template
    xterm="xterm -e \"\$1\""
    
    # insert
    BASHRUN_COMMAND=${xterm/\$1/$BASHRUN_COMMAND}

    bashrun.debug "$BASHRUN_COMMAND"

    return 0
}

function bashrun.command.add_pager {
    BASHRUN_COMMAND="$BASHRUN_COMMAND | ${PAGER:-less -f}"
}
