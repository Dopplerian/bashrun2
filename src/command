# -*- shell-script -*-

################################################################################

BASHRUN_COMMAND=''
BASHRUN_COMMAND_LINE=''
BASHRUN_COMMAND_WORD=''

function §command.unquote {

    command="$BASHRUN_COMMAND"
    # unquote quoted &;|
    command=${command//\\&/&}
    command=${command//\\|/|}
    command=${command//\\;/;}
    command=${command//&&/ && }
    command=${command//||/ || }

    BASHRUN_COMMAND=$command
}

function §command.get_line {
    # updates BASHRUN_COMMAND_LINE to contain the complete and
    # verbatim line entered by the user.
    
    local command_line=''
    local histtimeformat=$HISTTIMEFORMAT
    unset HISTTIMEFORMAT

    [[ $(history 1) =~ \ +[0-9]+?\ +(.+?) ]]
    BASHRUN_COMMAND_LINE=${BASH_REMATCH[1]}
    
    if [[ "$histtimeformat" != "" ]]; then
	HISTTIMEFORMAT=$histtimeformat
    fi
    echo "$BASHRUN_COMMAND_LINE"
}

function §command.get_word {

    # updates BASHRUN_COMMAND_WORD to contain the first word of the
    # current command.

    local word="$BASHRUN_COMMAND"

    word=${word//\\ /<qspace>}
    if [[ "$word" =~ ([^\ \&\;\|]+) ]]; then
	word=${BASH_REMATCH[1]}
    fi
    word=${word//<qspace>/\\ }
    word=$(echo $word | sed -r "s/^ +//;s/ +$//")
    word=$(echo $word | sed -r "s/^\\(+//;s/\\)+$//")

    BASHRUN_COMMAND_WORD="$word"
    §debug -v "$BASHRUN_COMMAND_WORD"
}

function §command.executable? {
    
    # check if BASHRUN_COMMAND_WORD is executable

    §command.get_word

    local word="$BASHRUN_COMMAND_WORD"
    local type=`type -t $word`

    if [[ "$type" =~ (alias|keyword|builtin) ]]; then
	§debug "$word-> $type -> yes"
	return 0
    fi

    if [[ "$type" == "function" ]]; then
	if §function.exported? $word; then
	    §debug "$word -> exported $type -> no"
	    return 0
	else	    
	    §debug "$word -> $type -> no"
	    return 1
	fi
    fi

    if [[ "$type" == "file" ]]; then
	if [[ `which $word 2> /dev/null` ]]; then
	    §debug "which: `which $word` -> yes"
	    return 0
	fi
	if [[ -x $word ]]; then
	    §debug "+x $word -> yes"
	    return 0
	fi
    fi

    §debug "$word -> no"
    return 1
}

function §command.builtin? {

    # check if BASHRUN_COMMAND_WORD is a shell builtin command

    §command.get_word
    local word="$BASHRUN_COMMAND_WORD"

    local result=`type $word 2>&1 | head -n1`

    if [[ "$result" =~ builtin ]]; then
	§debug "$word: yes"
	return 0
    fi
    §debug "$word: no"
    return 1
}

function §command.bookmark? {

    if §bookmarks.seek "$1"; then
	return 0
    fi
    return 1
}

function §command.add_su {

    local user=${1:-root}

    # COMMAND goes into su -c '' -> escape single quotes
    BASHRUN_COMMAND=${BASHRUN_COMMAND//\'/\\\'}

    # prompt for username
    if [[ "$user" == "?" ]]; then
	echo -ne 'Username: '
	read user
    fi

    # run the command itself in the background
    if [[ ! "$BASHRUN_COMMAND" =~ \&\ *$ ]]; then
	BASHRUN_COMMAND="su $user -c '$BASHRUN_COMMAND &> /dev/null &'"
    fi
    # run the su part (passwort entry) in foreground 
    BASHRUN_EXECMODE="" 
    §debug "$BASHRUN_COMMAND"
}

function §command.add_terminal {

    §command.get_word

    if [[ "$BASHRUN_COMMAND_WORD" =~ (xterm|?rxvt?) ]]; then
	§debug "already in terminal"
	return 1
    fi

    if [[ $# -eq 1 ]]; then
	if ! §terminals.seek "$1"; then
	    terminals.seek 'default'
	fi
    fi

    if [[ "$(§terminal.get_name)" == "bashrun" ]]; then
	§terminals.seek 'default'
    fi

    # COMMAND goes into "" -> escape double quotes
    BASHRUN_COMMAND=${BASHRUN_COMMAND//\"/\\\"}

    BASHRUN_COMMAND="$(§terminal.get_command) \"$BASHRUN_COMMAND\""

    §debug "$BASHRUN_COMMAND"

    return 0
}

function §command.add_pager {
    BASHRUN_COMMAND="$BASHRUN_COMMAND | ${PAGER:-less -f}"
    §debug "$BASHRUN_COMMAND"
}
