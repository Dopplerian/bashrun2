# -*- shell-script -*-

################################################################################

§class "§mode" "name terminal geometry
                completion unmap:b feedback:b animated:b 
                onmap onunmap cmdnfh:b logfile current" ""

§function.clone "§mode.new" "§_mode.new"
§function.clone "§mode.get_geometry" "§_mode.get_geometry"
§function.clone "§modes.dump" "§_modes.dump"

################################################################################

function §mode.new { 

    §_mode.new "$1"
    §mode.set_terminal "xterm -geometry %g -name bashrun-%m"
    §mode.set_geometry "80x24"
    §mode.set_current "0"
    §mode.set_completion 'complete'
    §mode.set_unmap '0'
    §mode.set_animated '0'
    §mode.set_onmap ""
    §mode.set_onunmap ""
    §mode.set_feedback "0"
    §mode.set_logfile "/dev/null"
}

function §mode.get_geometry {
    
    if [[ $# -eq 0 ]]; then
	§_mode.get_geometry
	return 0
    fi

    local wanted=${1:-0}
    local geometry="$(§_mode.get_geometry)"
    local g="" i=0

    for g in $geometry; do	
	if [[ i -eq $wanted ]]; then
	    echo "$g"
	    break
	else
	    ((i+=1))
	fi
    done
}

function §mode.unmap? {
    [[ "$(§mode.get_unmap)" == "1" && BASHRUN_DEBUG -eq 0 ]]
}

function §modes.init {
    §modes.seek "$BASHRUN_MODE";
    §mode.init
}

function §mode.init {

    local name="$(§mode.get_name)"

    local onmap="$(§mode.get_onmap)"
    local onunmap="$(§mode.get_onunmap)"

    if §function.defined? "+mode-$name-init"; then
	§debug -v "+mode-$name-init"
	+mode-$name-init
    fi

    # apply animation
    if [[ "$(§mode.get_animated)" == "1" ]]; then
	§window.animate 1
    else
	§window.animate 0
    fi

    # init logfile
    bashrun_logfile="$(§mode.get_logfile)"

    # init completion
    §completion.init

    # dump modeinfo for frontend if required
    [[ BASHRUN_FRONTEND -eq 1 ]] && §mode.write_info
}

function §mode.write_info {
    local mode="$(§mode.get_name)"
    local file="$bashrun_cache_home/${mode}-info"
    
    local terminal="$(§mode.get_terminal)"
    local onmap="$(§mode.get_onmap)"
    local onunmap="$(§mode.get_onunmap)"

    §quote terminal onmap onunmap

    echo "# mode info
          pid=$$
          wid=$WINDOWID
	  terminal=$terminal
          geometry=$(§mode.get_geometry 0)
          feedback=$(§mode.get_feedback)
          animated=$(§mode.get_animated)
          onmap=$onmap
          onunmap=$onunmap" > $file
}

function §mode.reset {
    
    local name="$(§mode.get_name)"
    if [[ "$(type -t +mode-$name-leave)" == "function" ]]; then
	+mode-$name-leave
    fi
}

function §mode.code {

    local name="$(§mode.get_name)"
    local terminal="$(§mode.get_terminal)"
    local completion="$(§mode.get_completion)"
    local unmap="$(§mode.get_unmap)"
    local geometry="$(§mode.get_geometry)"
    local animated="$(§mode.get_animated)"
    local onmap="$(§mode.get_onmap)"
    local onunmap="$(§mode.get_onunmap)"
    local feedback="$(§mode.get_feedback)"
    local logfile="$(§mode.get_logfile)"

    §print_line "mode $name" "#" "80"
    echo

    echo "+mode '$name'"
    echo "  --terminal '$terminal'"
    [[ "$geometry" != '80x24' ]] && echo "  --geometry '$geometry'"
    [[ "$completion" != 'complete' ]] && echo "  --completion '$completion'"
    [[ "$unmap" != '0' ]] && echo "  --unmap '$unmap'"
    [[ "$animated" != '0' ]] && echo "  --animated '$animated'"
    [[ "$onmap" != '' ]] && echo "  --onmap '$onmap'"
    [[ "$onunmap" != '' ]] && echo "  --onunmap '$onunmap'"
    [[ "$feedback" != '0' ]] && echo "  --feedback '$feedback'"
    [[ "$logfile" != '/dev/null' ]] && echo "  --logfile '$logfile'"
    echo

    if §function.defined? "+mode-$name-init"; then
	§function.code "+mode-$name-init"
	echo
    fi
}

function §modes.dump {

    local file="$_OBJECTS_DATA_HOME/${1:-§modes.dump}"
    local mode=''
    local func=''
    local current=$(§mode.get_name)    

    §_modes.dump "${1:-§modes.dump}"

    §modes.seek_start
    while §modes.next?; do
	mode=$(§mode.get_name)
	
	func="+mode-$mode-init"
	if §function.defined? "$func"; then
	    §function.code "$func" >> $file
	fi
	§modes.next
    done
    §modes.seek $current

    # bashrun completion helper
    §modes.list > $bashrun_cache_home/modes
}
