# -*- shell-script -*-

function bootstrap {

    source $BASHRUN_SHARE/xdotool
    source $BASHRUN_SHARE/message

    # check for xdotool
    if ! §xdotool.available?; then
	if [[ BASHRUN_XDOTOOL -eq 1 ]]; then
	    §message "Error" "Please install xdotool." &>/dev/null
	else
	    §message "Error" "Please install xdotool>=1.20100416.2809." &>/dev/null
	fi
	exit 1
    fi

    # bootstrap if a) rcfile doesn't exist
    #              b) rcfile is from a legacy version
    #              c) .bashrc is not set up
    
    if ([[ ! -f $BASHRUN_RCFILE \
	|| ! "$(head -n1 $BASHRUN_RCFILE 2>/dev/null)" =~ BASHRUN_CONFIG_VERSION ]] \
	|| ! grep 'BASHRUN -eq 1' $HOME/.bashrc &>/dev/null); then

	source $BASHRUN_SHARE/bootstrap
    fi

    # create modeinfo
    source $BASHRUN_SHARE/utils
    source $BASHRUN_SHARE/globals
    source $BASHRUN_SHARE/config
    source $BASHRUN_SHARE/plugin
    source $BASHRUN_SHARE/geometry
    source $BASHRUN_SHARE/registry
    source $BASHRUN_SHARE/progress
    source $BASHRUN_SHARE/terminals
    source $BASHRUN_SHARE/window
    source $BASHRUN_SHARE/modes
    source $BASHRUN_SHARE/core 
    source $BASHRUN_RCFILE 

    # load mode config
    §configs.restore_core "modes" &>/dev/null
    §configs.collect_user_configs "modes"

    §configs.seek "modes" && §config.restore 

    # get requested mode
    if ! §modes.seek "$mode"; then
	mode="bashrun"
	§modes.seek $mode
    fi
    §mode.write_info
}

function source_window {

    # create the environment §window expects and set wid

    BASHRUN_MODE="$mode"
    source $BASHRUN_SHARE/xdotool
    source $BASHRUN_SHARE/geometry
    source $BASHRUN_SHARE/window

    BASHRUN_WINDOW_ANIMATE="$animated"
    function §mode.get_animated { echo $animated; }
    function §mode.get_geometry { echo $geometry; }    
    function §mode.get_onmap { echo $onmap; }    
    function §mode.get_onunmap { echo $onunmap; }    

    §window.id $wid
}

function launch {

    # launch a one line terminal if this mode is animated
    saved_geometry="$geometry"

    if [[ animated -eq 1 ]]; then
	source $BASHRUN_SHARE/geometry
	
	§geometry.parse $geometry
    	§geometry.height 1
    	
	geometry="$(§geometry)"
    fi

    if [[ BASHRUN_DEBUG -eq 1 ]]; then
	geometry="80x24"
    fi

    # insert geometry and mode into terminal command
    terminal=${terminal//%g/$geometry}
    terminal=${terminal//%m/$mode}

    # launch terminal
    BASHRUN=1 \
	BASHRUN_MODE="$mode" \
	BASHRUN_FEEDBACK="$feedback" \
	BASHRUN_DEBUG=$BASHRUN_DEBUG \
	$terminal &    

    # wait for the new instance to register and get it's window id and pid
    widfile="$BASHRUN_CACHE_HOME/${mode}-wid"
    wait_until "[[ -f $widfile ]]"
    wid="$(<$widfile)"
    
    pidfile="$BASHRUN_CACHE_HOME/${mode}-pid"
    wait_until "[[ -f $pidfile ]]"
    pid="$(<$pidfile)"

    source_window
    geometry="$saved_geometry"    

    §window.map fast &>/dev/null
}

function remote {

    # wait until a newly started instance is ready
    if wait_until "[[ -f $BASHRUN_CACHE_HOME/${mode}-ready ]]"; then
	
        # put "<action> <cmd>" in the "remote" file
	echo $@ > $BASHRUN_DATA_HOME/remote

        # send SIGUSR1 to bashrun to pick it up (see §remote)
	kill -USR1 "$(<$BASHRUN_CACHE_HOME/${mode}-pid)"
    else
	echo "bashrun: error: bashrun-$mode not ready"
	return 1
    fi
    return 0
}

function wait_until { 
    # wait until code returns success,
    # bail out after 3 secs (30*0.1)
    # e.g. wait_until "[[ -f some_file ]]"
    #      wait_until "§window.mapped?"

    local code=${1:-:}
    local attempts=30

    eval "until $code; do
	if [[ attempts -eq 0 ]]; then
	    exit 1
	fi
	((attempts-=1))
	sleep 0.1
    done"
    return 0
}

function version {
    . $BASHRUN_SHARE/globals 2> /dev/null
    echo "bashrun $BASHRUN_VERSION Copyright (C) 2010 Henning Bekel <h.bekel@googlemail.com>"
}

function usage {
    echo "Usage: bashrun [option] [command] [args]

  Options: 

    -v, --version : show version information and exit
    -h, --help    : show this message and exit
    -m, --mode    : select mode to launch/control
    -d, --debug   : enable debugging on startup

  Commands: 
       
    show      : show window, move to current desktop and focus
    hide      : hide window 
    toggle    : hide if visible, show if hidden
    smart     : move window up front if not focused/visible, hide otherwise  
    restart   : restart bashrun 
    quit,exit : terminate bashrun
    wid       : print window id
    pid       : print pid of bashrun session

    su <cmd>       : run <cmd> as root, using bashrun for password entry
    do <act> <cmd> : remotely invoke <action> for <cmd>
    wait <state>   : wait until bashrun is in <state> ([map|unmap|ready])

  Press F1 in bashrun to list the current keybindings.

  For more information, see bashrun(1) or visit http://bashrun.sourceforge.net
"

}
