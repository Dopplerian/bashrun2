# -*- shell-script -*-

function create_modeinfo {

    # initialize object system
    source $bashrun_site/objects
    §objects.site $bashrun_site
    §objects.cache_home $bashrun_cache_home
    §objects.data_home $bashrun_cache_home
    §objects.namespace "bashrun"
    
    source $bashrun_site/utils
    source $bashrun_site/message
    source $bashrun_site/config
    source $bashrun_site/plugin
    source $bashrun_site/geometry
    source $bashrun_site/registry
    source $bashrun_site/progress
    source $bashrun_site/terminals
    source $bashrun_site/window
    source $bashrun_site/modes
    source $bashrun_site/core 

    # check rcfile syntax
    if ! §syntax? "$bashrun_rcfile"; then
	errors="$(<$bashrun_cache_home/errors)"
	errors="${errors//$'\n'/\\n}"
	§message "Syntax Errors" \
	    "The configuration file contains syntax errors:

             $errors

             Aborting. Please fix and retry."
	exit 1
    else
	§debug "using" -c "$(§tilde_path $bashrun_rcfile)"
	source $bashrun_rcfile
    fi
    
    # load modes from configuration file
    §configs.restore_core "modes" &>/dev/null
    §configs.collect_user_configs "modes"

    §configs.seek "modes" && §config.restore 

    # get requested mode
    if ! §modes.seek "$mode"; then
	mode="bashrun"
	§modes.seek $mode
    fi
    §mode.write_info
}

function source_window {

    # create the environment §window expects and set wid

    BASHRUN_MODE="$mode"
    source $bashrun_site/geometry
    source $bashrun_site/window

    bashrun_window_animate="$animated"
    function §mode.get_animated { echo $animated; }
    function §mode.get_geometry { echo $geometry; }    
    function §mode.get_onmap { echo $onmap; }    
    function §mode.get_onunmap { echo $onunmap; }    

    §window.id $wid
}

function launch {

    # launch a one line terminal if this mode is animated
    saved_geometry="$geometry"

    if [[ animated -eq 1 ]]; then
	source $bashrun_site/geometry
	
	§geometry.parse $geometry
    	§geometry.height 1
    	
	geometry="$(§geometry)"
    fi

    if [[ BASHRUN_DEBUG -eq 1 ]]; then
	geometry="80x24"
    fi

    # insert geometry and mode into terminal command
    terminal=${terminal//%g/$geometry}
    terminal=${terminal//%m/$mode}

    # fix known issues with certain terminals...
    for t in $terminal; do break; done

    if [[ "$t" == "xterm" ]]; then
	# enable meta keybindings
	fix='-xrm XTerm**metaSendsEscape:True '

    elif [[ "$t" =~ urxvtc? ]]; then
	# enable ctrl-arrow keys
	fix='-keysym.Control-Up "\033[1;5A" '
	fix+='-keysym.Control-Down "\033[1;5B" '
	fix+='-keysym.Control-Left "\033[1;5D" '
	fix+='-keysym.Control-Right "\033[1;5C"'
    fi

    # launch terminal
    BASHRUN=1 \
	BASHRUN_FRONTEND=1 \
	BASHRUN_MODE="$mode" \
	BASHRUN_FEEDBACK="$feedback" \
	BASHRUN_DEBUG=$BASHRUN_DEBUG \
	$terminal $termopts $fix &    

    # wait for the new instance to register and get it's window id and pid
    widfile="$bashrun_cache_home/${mode}-wid"
    wait_until "[[ -f $widfile ]]"
    wid="$(<$widfile)"
    
    pidfile="$bashrun_cache_home/${mode}-pid"
    wait_until "[[ -f $pidfile ]]"
    pid="$(<$pidfile)"

    source_window
    geometry="$saved_geometry"    

    §window.map fast &>/dev/null
}

function remote {

    # wait until a newly started instance is ready
    if wait_until "[[ -f $bashrun_cache_home/${mode}-ready ]]"; then
	
        # put "<action> <cmd>" in the "remote" file
	echo $@ > $bashrun_data_home/$mode-remote

        # send SIGUSR1 to bashrun to pick it up (see §remote)
	kill -USR1 "$(<$bashrun_cache_home/${mode}-pid)"
    else
	echo "bashrun: error: bashrun-$mode not ready"
	return 1
    fi
    return 0
}

function wait_until { 
    # wait until code returns success,
    # bail out after 3 secs (30*0.1)
    # e.g. wait_until "[[ -f some_file ]]"

    local code=${1:-:}
    local attempts=30

    eval "until $code; do
	if [[ attempts -eq 0 ]]; then
	    exit 1
	fi
	((attempts-=1))
	sleep 0.1
    done"
    return 0
}

function version {
    . $bashrun_site/globals 2> /dev/null
    echo "bashrun $bashrun_version Copyright (C) 2010 Henning Bekel <h.bekel@googlemail.com>"
}

function usage {
    echo "Usage: bashrun [option] [command [arg...]] [-- termopts]

  Options: 

    -v, --version : show version information and exit
    -h, --help    : show this message and exit
    -m, --mode    : select mode to launch/control
    -d, --debug   : enable debugging on startup

  Commands: 
       
    show      : show window, move to current desktop and focus
    hide      : hide window 
    toggle    : hide if visible, show if hidden
    smart     : move window up front if not focused/visible, hide otherwise  
    wid       : print window id
    pid       : print pid of bashrun session
    reload    : reload configuration
    restart   : restart bashrun 
    quit,exit : terminate bashrun

    su <cmd>         : run <cmd> as root, using bashrun for password entry
    do <act> [<cmd>] : remotely invoke <action> [<cmd>]

  Press F1 in bashrun to list the current keybindings.

  For more information, see bashrun(1) or visit http://bashrun.sourceforge.net
"

}
