# -*- shell-script -*-

function create_modeinfo {

    # initialize object system
    source $bashrun_site/objects
    §objects.site $bashrun_site
    §objects.cache_home $bashrun_cache_home
    §objects.data_home $bashrun_cache_home
    §objects.namespace "bashrun"
    
    source $bashrun_site/utils
    source $bashrun_site/readline
    source $bashrun_site/message
    source $bashrun_site/config
    source $bashrun_site/plugin
    source $bashrun_site/geometry
    source $bashrun_site/registry
    source $bashrun_site/progress
    source $bashrun_site/terminals
    source $bashrun_site/window
    source $bashrun_site/modes
    source $bashrun_site/core 

    # check rcfile syntax
    if ! §syntax? "$bashrun_rcfile"; then
	errors="$(<$bashrun_cache_home/errors)"
	errors="${errors//$'\n'/\\n}"
	§message "Syntax Errors" \
	    "The configuration file contains syntax errors:

             $errors

             Aborting. Please fix and retry."
	exit 1
    else
	§debug "using" -c "$(§tilde_path $bashrun_rcfile)"
	source $bashrun_rcfile
    fi
    
    # load modes from configuration file
    §configs.restore_core "modes" &>/dev/null
    §configs.collect_user_configs "modes"

    §configs.seek "modes" && §config.restore 

    # get requested mode
    if ! §modes.seek "$mode"; then
	echo "bashrun: error: no such mode: \`$mode', exiting..."
	exit 1
    fi
    §mode.write_info
}

function source_window {

    # create the environment §window expects and set wid

    BASHRUN_MODE="$mode"
    source $bashrun_site/geometry
    source $bashrun_site/window

    bashrun_window_animate="$animated"
    function §mode.get_animated { echo $animated; }
    function §mode.get_geometry { echo $geometry; }    
    function §mode.get_onmap { echo $onmap; }    
    function §mode.get_onunmap { echo $onunmap; }    

    §window.id $wid
}

function launch {

    # launch a one line terminal if this mode is animated
    saved_geometry="$geometry"

    if [[ animated -eq 1 ]]; then
	source $bashrun_site/geometry
	
	§geometry.parse $geometry
    	§geometry.height 1
    	
	geometry="$(§geometry)"
    fi

    if [[ BASHRUN_DEBUG -eq 1 ]]; then
	geometry="80x24"
    fi

    # insert geometry and mode into terminal command
    terminal=${terminal//%g/$geometry}
    terminal=${terminal//%m/$mode}

    # get first word of terminal line (program binary)
    for prog in $terminal; do break; done

    # fix known issues with certain terminals...

    if [[ "$prog" == "xterm" ]]; then
	# enable meta keybindings
	termfix='-xrm XTerm**metaSendsEscape:True '

    elif [[ "$prog" =~ urxvtc? ]]; then
	# enable ctrl-arrow keys
	termfix='-keysym.Control-Up "\033[1;5A" '
	termfix+='-keysym.Control-Down "\033[1;5B" '
	termfix+='-keysym.Control-Left "\033[1;5D" '
	termfix+='-keysym.Control-Right "\033[1;5C"'
    fi

    if ! type -p $prog &>/dev/null; then
	source $bashrun_site/message
	§message "Error" \
                 "The terminal program \"$prog\" was not found. Please
                  make sure that the terminal command line is correct:

                 $terminal

                 (+mode $mode --terminal)"
	rm "$modeinfo"
	exit 1
    fi

    abort="$bashrun_cache_home/${mode}-abort"

    error="$(BASHRUN=1 \
	BASHRUN_FRONTEND=1 \
	BASHRUN_MODE="$mode" \
	BASHRUN_FEEDBACK="$feedback" \
	BASHRUN_DEBUG=$BASHRUN_DEBUG \
	$terminal $termopts $termfix -e bash \
	--rcfile __PREFIX__/share/bashrun/bashrc 2>&1)" || { 

	   touch "$abort"
	   [[ -f "$modeinfo" ]] && rm "$modeinfo"
	   
	   source $bashrun_site/message
	   §message "Error" \
                    "Failed to launch terminal. Please make sure that
                     the terminal command line is correct:

                     $terminal $termopts

                     (+mode $mode --terminal)

                     $error"
    } &

    # wait for the new instance to be ready
    # (abort if the terminal command failed...)

    wait_until "brwctl bashrun-$mode &>/dev/null" "[[ -f '$abort' ]]"
    status=$?

    [[ status -eq 1 ]] && exit 1    
    if [[ status -eq 2 || -f "$abort" ]]; then
	rm "$abort" 
	exit 1
    fi

    wid="$(brwctl bashrun-$mode)"

    source_window
    geometry="$saved_geometry"    

    §window.map fast &>/dev/null
}

function remote {

    # wait until a newly started instance is ready
    if wait_until "[[ -f $bashrun_cache_home/${mode}-ready ]]"; then
	
        # put "<action> <cmd>" in the "remote" file
	echo "$PWD" "$@" > $bashrun_data_home/$mode-remote

        # send SIGUSR1 to bashrun to pick it up (see §remote)
	kill -USR1 "$(<$bashrun_cache_home/${mode}-pid)"
    else
	echo "bashrun: error: bashrun-$mode not ready"
	return 1
    fi
    return 0
}

function wait_until { 
    # wait until code returns success,
    # bail out after 15 secs (150*0.1s)
    # e.g. wait_until "[[ -f some_file ]]"

    local wait_condition=${1:-:}
    local break_condition=${2:-false}
    local attempts=150

    eval "until $wait_condition; do
	if [[ attempts -eq 0 ]]; then
	    return 1
	fi
        if $break_condition; then
            return 2
        fi
	((attempts-=1))
	sleep 0.1
    done
    return 0"
    return $?
}

function version {
    . $bashrun_site/globals 2> /dev/null
    echo "bashrun $bashrun_version Copyright (C) 2010 Henning Bekel <h.bekel@googlemail.com>"
}

function usage {
    echo "Usage: bashrun [option] [command [arg...]] [-- termopts]

  Options: 

    -v, --version : show version information and exit
    -h, --help    : show this message and exit
    -m, --mode    : select mode to launch/control
    -d, --debug   : enable debugging on startup

  Commands: 
       
    show      : show window, move to current desktop and focus
    hide      : hide window 
    toggle    : hide if visible, show if hidden
    smart     : move window up front if not focused/visible, hide otherwise  
    wid       : print window id
    pid       : print pid of bashrun session
    reload    : reload configuration
    restart   : restart bashrun 
    quit,exit : terminate bashrun

    su <cmd>         : run <cmd> as root, using bashrun for password entry
    do <act> [<cmd>] : remotely invoke <action> [<cmd>]

  Press F1 in bashrun to list the current keybindings.

  For more information, see bashrun(1) or visit http://bashrun.sourceforge.net
"

}
