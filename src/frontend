# -*- shell-script -*-

############################################################

BASHRUN_MODE="$mode"

. $BASHRUN_SHARE/utils
. $BASHRUN_SHARE/globals
. $BASHRUN_SHARE/config
. $BASHRUN_SHARE/geometry
. $BASHRUN_SHARE/registry
. $BASHRUN_SHARE/progress
. $BASHRUN_SHARE/terminals
. $BASHRUN_SHARE/window
. $BASHRUN_SHARE/modes
. $BASHRUN_RCFILE

# load modes and terminals 
§configs.restore_core 
§configs.collect_user_configs
§configs.seek "modes" && §config.restore 
§configs.seek "terminals" && §config.restore 

############################################################

launch () {

    # get the bashrun terminal
    §terminals.seek "bashrun"
    
    # get requested mode
    if ! §modes.seek "$mode"; then
	mode="launcher"
	§modes.seek $mode
    fi

    # find out whether this mode has feedback enabled
    feedback="$(§mode.get_feedback)"

    # find out whether it's animated
    animation="$(§mode.get_anim)"

    # get initial terminal geometry for the requested mode
    geometry=$(§mode.get_default_geometry)
    §geometry.parse $geometry

    # start with a one line terminal if this mode is animated
    if [[ animation -eq 1 ]]; then
	§geometry.height 1
	geometry="$(§geometry)"
    fi

    # get terminal command and insert properties and geometry from
    # requested mode
    terminal="$(§terminal.get_command)"
    terminal=${terminal//%m/$mode}
    terminal=${terminal//%g/$geometry}        

    # launch terminal
    BASHRUN=1 \
	BASHRUN_MODE="$mode" \
	BASHRUN_FEEDBACK="$feedback" \
	BASHRUN_DEBUG=$BASHRUN_DEBUG \
	$terminal $termopts &    

    # wait for the new instance to register and get it's window id
    echo "$(waitwid)"
}

function waitwid { 
   # wait until new instance is registered and return it's wid
    
    local attempts=50
    local widfile="$BASHRUN_CACHE_HOME/${mode}-wid"

    until [[ -f $widfile ]]; do
	if [[ attempts -eq 0 ]]; then
	    echo "failed"
	    exit 1
	fi
	((attempts-=1))
	sleep 0.1
    done
    echo "$(<$widfile)" 
}

function remote {

    # wait until a newly started instance is ready
    until [[ -f $BASHRUN_CACHE_HOME/${mode}-ready ]]; do
	sleep 0.1
    done

    # put "<action> <cmd>" in the "remote" file
    echo "$@" > $BASHRUN_DATA_HOME/remote

    # send SIGUSR1 to bashrun to pick it up (see §remote)
    kill -USR1 "$(<$BASHRUN_CACHE_HOME/${mode}-pid)"
}
