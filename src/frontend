
# -*- shell-script -*-

############################################################

. $BASHRUN_SHARE/utils
. $BASHRUN_SHARE/globals
. $BASHRUN_SHARE/config
. $BASHRUN_SHARE/geometry
. $BASHRUN_SHARE/instance
. $BASHRUN_SHARE/registry
. $BASHRUN_SHARE/window
. $BASHRUN_SHARE/terminals
. $BASHRUN_SHARE/modes
. $BASHRUN_RCFILE

# load modes and terminals 
bashrun.configure.type "§modes"
bashrun.configure.type "§terminals"

############################################################

function version {
    echo "bashrun $BASHRUN_VERSION Copyright (C) 2009 Henning Bekel <h.bekel@googlemail.com>"
}

function usage {

    version
    echo "
Usage: bashrun [option]

   Options:
     -v, --version : show version information
     -h, --help    : show this message
     -d, --debug   : start bashrun in debug mode

     Available if xdotool(1) is installed:
       --show    : show bashrun window and focus it
       --hide    : hide the bashrun window
       --toggle  : toggle window visibility
       --exit    : exit bashrun
       --restart : restart bashrun
       --su cmd  : run command as root,
                   prompts for password in bashrun
       --wid     : print window id
       --wait    : wait until window is unmapped
       --debug   : toggle debug mode

       Press F1 in bashrun to list the current keybindings.

For more information, see bashrun(1) or visit http://bashrun.sourceforge.net
"
}

switch=""
qualifier="last"
qualifier_policy="new"
mode="launcher"
command="toggle"
command_modifier=""
command_args=()
termopts=()

function parse_arguments () {

    # bashrun [--switch] [qualifier] [mode] [[--]command] [args]

    function debug? { return 1; }

    local switches=" version:v help:h debug:d upgrade:U "
    local switched=0

    local qualifiers=" new first last all "
    local qualified=0

    local modes=" $(§modes.all) "
    local mode_set=0

    local commands=" show hide toggle exit restart remote su wid wait "
    local command_set=0

    local terminated=0

    local word=""
    local cond=""
    local pos=-1

    until [[ $# -eq 0 ]]; do
	((pos+=1))
	debug? && echo "-- $pos: $1 ---------------------"

	word="$1"
	cond=""

	# if -- the remaining words are either command arguments or termopts
	if [[ "$1" == "--" ]]; then
	    terminated=1
	    switched=1
	    qualified=1
	    mode_set=1
	    command_set=1
	    shift; continue
	fi

	# collect terminal options
	if [[ "$terminated" == "1" ]]; then
	    debug? && echo "terminal option: $1"
	    termopts[${#termopts[@]}]="$1"
	    shift; continue	
	fi

	# check for switch or command
	if [[ "$terminated" == "0" ]]; then
	    if [[ "$word" =~ ^--?(.+) ]]; then
		word="${BASH_REMATCH[1]}"
		debug? && echo "switch or action: $word"
		
	        # check for single character switch
		if [[ "$switched" == "0" && "$word" =~ ^[a-zA-Z]$ ]]; then
		    debug? && echo "single character switch: $word"
		    
		    [[ "$switches" =~ \ ([^:]+):${word}\  ]]		    
		    switch="${BASH_REMATCH[1]}"
		    switched=1
		    debug? && echo "switch: $switch"
		    shift; continue
		fi
		
	        # check for --command
		if [[ "$command_set" == "0" && "$commands" =~ " $word " ]]; then		
		    if [[ "$word" =~ ^([^:]+):([^:]+) ]]; then
			word="${BASH_REMATCH[1]}"
			cond="${BASH_REMATCH[2]}"
		    fi
		    debug? && echo "--command? word='$word' cond='$cond'"
		    [[ -n "$cond" ]] && command_modifier="$cond"
		    command="$word"		    
		    command_set=1		   
		    switched=1
		    qualified=1
		    mode_set=1
		
		    debug? && echo "command: $command"
		    shift; continue
		fi
	    
	        # check for long switch
		if [[ "$switched" == "0" && "$switches" =~ \ $word:[a-zA-Z]\  ]]; then
		    switch="$word"
		    switched=1
		    debug? && echo "long switch: $switch"
		    shift; continue
		fi
	    fi 
	fi

	if [[ "$qualified" == "0" ]]; then
 	    if [[ "$word" =~ ^([^:]+):([^:]+) ]]; then
		word="${BASH_REMATCH[1]}"
		cond="${BASH_REMATCH[2]}"
	    fi
	    debug? && echo "qualifier? word='$word' cond='$cond'"
	    
	    if [[ "$qualifiers" =~ " $word " ]]; then
		qualifier="$word"
		[[ -n "$cond" ]] && qualifier_policy="$cond"
		qualified=1
		switched=1
		debug? && echo "qualifier: $qualifier, $qualifier_policy: $qualifier_policy"
		shift; continue
	    fi
	fi

	if [[ "$mode_set" == "0" && "$modes" =~ " $word " ]]; then
	    mode="$word"
	    mode_set=1
	    switched=1
	    qualified=1
	    debug? && echo "mode: $mode ($modes)"
            shift; continue
	fi

	if [[ "$command_set" == "0" ]]; then
	    if [[ "$word" =~ ^([^:]+):([^:]+) ]]; then
		word="${BASH_REMATCH[1]}"
		cond="${BASH_REMATCH[2]}"
	    fi
	    debug? && echo "command? word='$word' cond='$cond'"

	    if [[ "$commands" =~ " $word " ]]; then		
		command="$word"
		[[ -n "$cond" ]] && command_modifier="$cond"
		command_set=1
		switched=1
		qualified=1
		mode_set=1
		debug? && echo "command: $command, modifier: $command_modifier"
		shift; continue
	    fi
	fi

	# collect command arguments
	if [[ terminated -eq 0 ]]; then
	    debug? && echo "command arg: $word"
	    command_args[${#command_args[@]}]="$word"
	fi
	shift
    done    

    # quote terminal options
    if [[ "${termopts[@]}" != "" ]]; then
	termopts="$(printf "%q " ${termopts[@]})"
    fi

    if debug?; then
	echo "--------------------------------------------------------------------------------"
	[[ -n "$switch" ]] && echo "switch     : $switch"
	echo "
qualifier  : $qualifier
  policy   : $qualifier_policy

mode       : $mode

command    : $command
  modifier : $command_modifier
  args     : (${command_args[@]})

termopts   : (${termopts[@]})"
    fi

    unset -f debug?
}

function waitwid {
    
    expected=$1
    ((expected+=1))

    # wait for instance to register
    until [[ "$(bashrun.registry.length)" -eq expected ]]; do
	sleep 0.2
    done
    bashrun.registry.get_last_wid
}
