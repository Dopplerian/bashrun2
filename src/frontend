# -*- shell-script -*-

function create_modeinfo {

    # initialize object system
    source $bashrun_site/objects
    §objects.site $bashrun_site
    §objects.cache_home $bashrun_cache_home
    §objects.data_home $bashrun_cache_home
    §objects.namespace "bashrun"
    
    source $bashrun_site/utils
    source $bashrun_site/readline
    source $bashrun_site/message
    source $bashrun_site/config
    source $bashrun_site/plugin
    source $bashrun_site/geometry
    source $bashrun_site/registry
    source $bashrun_site/progress
    source $bashrun_site/terminals
    source $bashrun_site/window
    source $bashrun_site/modes
    source $bashrun_site/core 

    # check rcfile syntax
    if ! §syntax? "$bashrun_rcfile"; then
	errors="$(<$bashrun_cache_home/errors)"
	errors="${errors//$'\n'/\\n}"
	§message "Syntax Errors" \
	    "The configuration file contains syntax errors:

             $errors

             Aborting. Please fix and retry."
	exit 1
    else
	§debug "using" -c "$(§tilde_path $bashrun_rcfile)"
	source $bashrun_rcfile
    fi
    
    # load modes from configuration file
    §configs.restore_core "modes" &>/dev/null
    §configs.collect_user_configs "modes"

    §configs.seek "modes" && §config.restore 

    # get requested mode
    if ! §modes.seek "$mode"; then
	echo "bashrun: error: no such mode: \`$mode', exiting..."
	exit 1
    fi
    §mode.write_info
}

function source_window {

    # create the environment §window expects and set wid

    BASHRUN_MODE="$mode"
    source $bashrun_site/geometry
    source $bashrun_site/window

    function §mode.get_geometry { echo $geometry; }    
    function §mode.get_onmap { echo $onmap; }    
    function §mode.get_onunmap { echo $onunmap; }    

    §window.id $wid
}

function launch {

    source $bashrun_site/terminals

    # launch a default sized terminal in debug mode
    if [[ BASHRUN_DEBUG -eq 1 ]]; then
	geometry="80x24"
    fi

    # get first word of terminal line (program binary)
    for prog in $terminal; do break; done

    # check if the terminal program is usable
    if ! type -p $prog &>/dev/null; then
	source $bashrun_site/message
	§message "Error" \
                 "The terminal program \"$prog\" was not found. Please
                  make sure that the terminal command template is correct:

                 $terminal

                 (+mode $mode --terminal)"
	rm "$modeinfo"
	exit 1
    fi

    # fix known issues with xterm or *rxvt's...

    if [[ "$prog" == "xterm" ]]; then
	# enable meta keybindings
	termfix='-xrm XTerm**metaSendsEscape:True '

    elif [[ "$prog" =~ *rxvtc? ]]; then
	# enable ctrl-arrow keys
	termfix='-keysym.Control-Up "\033[1;5A" '
	termfix+='-keysym.Control-Down "\033[1;5B" '
	termfix+='-keysym.Control-Left "\033[1;5D" '
	termfix+='-keysym.Control-Right "\033[1;5C"'
    fi

    # create terminal command
    launch="BASHRUN=1 \
            BASHRUN_FRONTEND=1 \
            BASHRUN_MODE=$mode \
	    BASHRUN_FEEDBACK=$feedback \
            BASHRUN_DEBUG=$BASHRUN_DEBUG \
            $(§terminal.expand "$terminal" \
                 'bash --rcfile __PREFIX__/share/bashrun/bashrc' \
                 "$mode" "$geometry" "$font" "$termopts $termfix")" 
               
    # clean whitespace
    launch="$(echo "$launch" | sed 's/[ \t]\+/ /g')"

    §debug -c "$mode:" -n "$launch"

    # file to flag aborting
    abort="$bashrun_cache_home/${mode}-abort"

    # launch the terminal command
    error="$(eval "$launch" 2>&1)" || { 

	   # terminal command failed	
	   touch "$abort"

	   # remove possibly bogus modeinfo
	   [[ -f "$modeinfo" ]] && rm "$modeinfo"	   

	   # notify user
	   source $bashrun_site/message
	   §message "Error" \
                    "Failed to launch terminal. Please make sure that
                     the terminal command line is correct:

                     $(§terminal.expand "$terminal" '...' \
                        "$mode" "$geometry" "$font" "$termopts")

                     (+mode $mode --terminal)

                     $error"
    } &

    # wait for the terminal window to be mapped...
    wait_until "brwctl bashrun-$mode &>/dev/null" "[[ -f '$abort' ]]"
    status=$?

    if [[ status -eq 1 ]]; then
	§debug fail "The terminal window never appeared... giving up."
	exit 1
    fi

    if [[ status -eq 2 || -f "$abort" ]]; then
	rm "$abort" 
	§debug fail "failed" -n "$error"
	exit 1
    fi

    wid="$(brwctl bashrun-$mode)"
    source_window

    §window.map
}

function remote {

    # wait until a newly started instance is ready
    if wait_until "[[ -f $bashrun_cache_home/${mode}-ready ]]"; then
	
        # put "<action> <cmd>" in the "remote" file
	echo "$PWD" "$@" > $bashrun_data_home/$mode-remote

        # send SIGUSR1 to bashrun to pick it up (see §remote)
	kill -USR1 "$(<$bashrun_cache_home/${mode}-pid)"
    else
	echo "bashrun: error: bashrun-$mode not ready"
	return 1
    fi
    return 0
}

function remote_control_code {
    cat <<EOF
if [[ BASHRUN -eq 0 ]]; then
     remote="\${XDG_CACHE_HOME:-\$HOME/.cache}/bashrun/remote.bash";
     [[ -f "\$remote" ]] && . "\$remote";
     unset remote;
fi
EOF
}

function wait_until { 
    # wait until code returns success,
    # bail out after 15 secs (150*0.1s)
    # e.g. wait_until "[[ -f some_file ]]"

    local wait_condition=${1:-:}
    local break_condition=${2:-false}
    local attempts=150

    eval "until $wait_condition; do
	if [[ attempts -eq 0 ]]; then
	    return 1
	fi
        if $break_condition; then
            return 2
        fi
	((attempts-=1))
	sleep 0.1
    done
    return 0"
    return $?
}

function version {
    . $bashrun_site/globals 2> /dev/null
    echo "bashrun $bashrun_version Copyright (C) 2010 Henning Bekel <h.bekel@googlemail.com>"
}

function usage {
    echo "Usage: bashrun [option] [command [arg...]] [-- termopts]

  Options: 

    -v, --version    : show version information and exit
    -h, --help       : show this message and exit
    -m, --mode       : select mode to launch/control
    -d, --debug      : launch in debug mode
    --remote-control : show code to enable remote control interface
                       
  Commands: 
       
    show      : show window, move to current desktop and focus
    hide      : hide window 
    toggle    : hide if visible, show if hidden
    smart     : move window up front if not focused/visible, hide otherwise  
    wid       : print window id
    pid       : print pid of bashrun session
    debug     : toggle debugging
    reload    : reload configuration
    restart   : restart bashrun 
    quit,exit : terminate bashrun

    su <cmd>         : run <cmd> as root, using bashrun for password entry
    do <act> [<cmd>] : remotely invoke <action> [<cmd>]

  Press F1 in bashrun to list the current keybindings.

  For more information, see bashrun(1) or visit http://bashrun.sourceforge.net
"

}
