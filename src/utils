# -*- shell-script -*-

################################################################################

BASHRUN_DEBUG_ACTION=0

function §bash3 {
    [[ ${BASH_VERSINFO[0]} -eq 3 ]]
}

function §bash4 {
    [[ ${BASH_VERSINFO[0]} -eq 4 ]]
}

function §defined? {
    [[ "${!1-X}" == "${!1-Y}" ]]
}

function §set? {
    (set -o | grep "$1" | grep on) &>/dev/null
}

function §function.defined? {
    [[ "$(type -t $1 2> /dev/null)" == "function" ]]
}

function §function.exported? () {
    declare -pfx | grep "declare -fx $1" &>/dev/null
}	

function §function.code {
    echo "$(type $1 | sed '1 d')"
}

function §function.clone {

    local function="$1"
    local newname="$2"

    if $(type -t $function &> /dev/null); then
	local code="$(echo -n '#'; type $function)"
	code="${code/$function \(\)/$newname ()}"
	eval "$code"
    else
	echo "§function.clone: error: no such function: $function"
    fi
}

function §interpolate {
    local str="$1"
    local var=""
    local val=""

    while [[ "$str" =~ \$([A-Za-z0-9_]+) ]]; do
	var=${BASH_REMATCH[1]}
	val=${!var}
	val=${val//\$/__DoLlArSiGn__}
	str=${str/\$$var/$val}
    done
    str=${str//__DoLlArSiGn__/\$}
    echo "$str"
}

function §debug {

    [[ BASHRUN_DEBUG -eq 0 ]] && return
    
    # color

    local w="\033[1;37m" # white
    local r="\033[1;31m" # red
    local g="\033[1;32m" # green 
    local b="\033[1;34m" # blue
    local c="\033[1;36m" # cyan
    local m="\033[1;35m" # magenta
    local y="\033[1;33m" # yellow
    local n="\033[0m"    # none
    local d="$b"         # default
    local v="$w"         # variable

    local col=""

    # print function name
    
    local _func=${FUNCNAME[1]}
    _func=${_func//}
    _func=${_func/§/}
    
    local _from=${FUNCNAME[2]}
    _from=${_from//}
    _from=${_from:-shell}

    case $1 in	
	fail)
	    col=$r
	    shift
	    ;;
	warn)
	    col=$y
	    shift
	    ;;
	info)
	    col=$g
	    shift
	    ;;
	emph)
	    col=$c
	    shift
	    ;;
	*)
	    col=$g
	    ;;
    esac
    if [[ BASHRUN_DEBUG_ACTION -eq 1 ]]; then
	echo -ne "$col$_from$n $d" >&2
    else
	echo -ne "$col$_func$n $d" >&2
    fi

    local str=''
    local requested=0

    for str in "$@"; do
	
	if [[ "${str:0:1}" == "-" && "$str" != "->" ]]; then # color option
	    col="${str:1:1}"
	    echo -ne "${!col}" >&2
	    requested=1

	elif §defined? "$str"; then # variable
	    if §defined? "$str"; then
		echo -ne "$d$str$b$v " >&2 # name
		echo -n  "${!str} "    >&2 #value 
	    fi
	else
	    [[ requested -eq 0 ]] && echo -ne "$d" >&2 
	    echo -n "$str " >&2
	    requested=0
	fi
    done
    echo -e "$n" >&2
}

function §separator {

    [[ BASHRUN_DEBUG -eq 0 ]] && return

    local y="\033[1;33m" # yellow
    local b="\033[1;34m" # blue
    local n="\033[0m"    # none
    local title=$1
    local width=${2:-$COLUMNS}

    
    echo -ne "$b"
    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -ne "-- $y$title$b "
    fi
    
    local i=0;
    for (( i=1; i<=$width; i++ )); do
	echo -n "-"
    done
    
    echo -ne "$n"
    echo
}

function §prepare_logfile {

    # set to /dev/null if empty
    if [[ "$BASHRUN_LOGFILE" == "" ]]; then 
	BASHRUN_LOGFILE="/dev/null"
    fi
 
    # touch unless exists
    if [[ ! -e "$BASHRUN_LOGFILE" ]]; then
	§debug "creating logfile $BASHRUN_LOGFILE"
	touch "$BASHRUN_LOGFILE"
    fi

    # revert to /dev/null unless writable
    if [[ ! -w "$BASHRUN_LOGFILE" ]]; then
	§debug "logfile $BASHRUN_LOGFILE is not writeable"
	BASHRUN_LOGFILE="/dev/null"
    fi
}

function §ks2kn {
    local keyseq=$1

    if §keynames.seek "$keyseq"; then
	echo $(§keyname.get_name)
	return 0
    fi

    local enter="Ret"
    local keyname=$keyseq

    keyname=${keyname/\\e/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\M-/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\\?/?}

    keyname=${keyname/C-m/$enter}
    if [[ "$keyname" =~ [a-zA-z]$enter ]]; then
	keyname=${keyname/$enter/-$enter}
    fi
    echo "$keyname"
}

function §print_line {

    local title=$1
    local char=${2:--}
    local width=${3:-$COLUMNS}
    local i;

    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -n "$char$char $title "
    fi

    for((i=0; i<$width; i++)); do
	echo -n $char
    done
    echo
}

function §print_header {
    
    local title="$1"

    # remove the namespace prefix
    local prefix="$(echo $_OBJECTS_NAMESPACE | tr "[:lower:]" "[:upper:]")"
    title=${title/${prefix}_/}

    local char=${2:-#}
    §print_line '' "$char"
    §print_line "$title" "$char" '-1'
    §print_line '' "$char"
    echo
}

function §print_bindings {
        
    # some colours (used in §print_bindings)
    local w="\033[1;37m" # white
    local r="\033[1;31m" # red
    local g="\033[1;32m" # green 
    local b="\033[1;34m" # blue
    local c="\033[1;36m" # cyan
    local m="\033[1;35m" # magenta
    local y="\033[1;33m" # yellow
    local n="\033[0m"    # none

    # display order of core actions, | denotes a newline
    local order="bashrun-bindings bashrun-manual debug | 
                 pass abort quit |
                 run term-run term-page term-hold | 
                 su-run su-term-run su-term-page su-term-hold |
                 show-manual show-info show-help |
                 browse google-search dict-lookup |
                 copy-to-clipboard filter-clipboard |
                 cycle-size resize-up resize-down resize-left resize-right"
        
    local id=""
    local bindings=""
    local keymap=""

    local covered=""

    for keymap in emacs vi-insert vi-command; do
	bindings="$(§bound_and_sorted $keymap)"
	if [[ -n "$bindings" ]]; then
	    echo -e "${c}$keymap:${n}\n"
	    for id in $bindings; do
		if [[ "$id" == "|" ]]; then		    
		    echo
		else
		    §print_binding "$id"
		fi
	    done
	    echo
	fi
    done
}

function §bound_and_sorted {
    
    local keymap="${1:-emacs}"
    local ids="$(§bindings.select keymap "$keymap")"

    local sorted=""
    local action=""
    local id=""
    local len=0
    local found=0

    # core actions
    for action in $order; do
	if [[ "$action" != '|' ]]; then
	    for id in $ids; do
		§bindings.seek "$id"
		if [[ "$(§binding.get_action)" == "$action" &&
			    "$(§binding.get_is_bound)" == "1" ]]; then
		    sorted="$sorted $id"
		    found=1
		fi
	    done
	else
	    len=${#sorted}
	    [[ ${sorted:$len-1:1} != '|' ]] && sorted="$sorted |"
	fi
    done
    
    # user actions
    local first=1

    for id in $ids; do
	§bindings.seek "$id"
	§actions.seek "$(§binding.get_action)"
	if [[ "$(§action.get_core)" != "1" && "$(§binding.get_is_bound)" == "1" ]]; then	    
	    found=1
	    if [[ "$first" == "1" ]]; then
		sorted="$sorted | $id"
		first=0
	    else
		sorted="$sorted $id"
	    fi
	fi
    done
    [[ found -eq 1 ]] && echo "$sorted"
}

function §print_binding {
    
    local id="$1"
    local name=""
    local desc=""
    local deps=""
    local keyname=""
    local keyseq=""

    §bindings.seek "$id"

    name="$(§binding.get_action)"
    
    §actions.seek "$name"
    desc="$(§action.get_description)"
    
    deps="$(§action.print_depends)"
    keyseq="$(§binding.get_keyseq)"
    
    if §keynames.seek "$keyseq"; then
	keyname="$(§keyname.get_name)"
    else
	keyname="$(§ks2kn $keyseq)"
    fi

    if [[ ! " $covered " =~ $keyname ]]; then
	echo -ne " ${w}$keyname\t${n}$desc"
	if [[ "$deps" != "" ]]; then
	    echo -e " (requires $deps${n})"
	else
	    echo
	fi
	covered="$covered $keyname"
    fi
}

function §tilde_path {
    # replace $HOME with a tilde for printing
    local path="$1"
    path=${path/$HOME/\~}
    echo "$path"
}
