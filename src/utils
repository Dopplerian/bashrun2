# -*- shell-script -*-

################################################################################

bashrun_debug_action=0

function §bash3 {
    [[ ${BASH_VERSINFO[0]} -eq 3 ]]
}

function §bash4 {
    [[ ${BASH_VERSINFO[0]} -eq 4 ]]
}

function §defined? {
    [[ "${!1-X}" == "${!1-Y}" ]]
}

function §set? {
    (set -o | grep "$1" | grep on) &>/dev/null
}

function §function.defined? {
    [[ "$(type -t $1 2> /dev/null)" == "function" ]]
}

function §function.exported? () {
    declare -pfx | grep "declare -fx $1" &>/dev/null
}	

function §function.code {
    echo "$(type $1 | sed '1 d')"
}

function §function.clone {

    local function="$1"
    local newname="$2"

    if $(type -t $function &> /dev/null); then
	local code="$(echo -n '#'; type $function)"
	code="${code/$function \(\)/$newname ()}"
	eval "$code"
    else
	echo "§function.clone: error: no such function: $function"
    fi
}

function §syntax? {
    local file="$1"
    local errorfile="$bashrun_cache_home/syntax-errors"
    local errors=""

    bash -n "$1" &> "$errorfile"
    errors="$(<$errorfile)"
    [[ -z "$errors" ]] && rm "$errorfile"

    [[ -z "$errors" ]]
}

function §quote { 
    declare -i times=1 i=0
    local varname=""

    if [[ "$1" =~ [0-9]+ ]]; then
	times=$1
	shift
    fi
    for varname in "$@"; do
	for (( i=0; i<$times; i++ )); do
	    eval "printf -v $varname '%q' \"\$$varname\""
	done
    done
}

function §interpolate {
    local str="$1"
    local var=""
    local val=""

    while [[ "$str" =~ \$([A-Za-z0-9_]+) ]]; do
	var=${BASH_REMATCH[1]}
	val=${!var}
	val=${val//\$/__DoLlArSiGn__}
	str=${str/\$$var/$val}
    done
    str=${str//__DoLlArSiGn__/\$}
    echo "$str"
}

function §replace {

    # §replace 'foo %b bar \%baz' %b quux
    # -> "foo quux bar %baz"

    local string="$1"
    local prefix="${2:0:1}"
    local pattern="${2:1}"
    local replacement="$3"

    local result="" char="" prev="" next=""
    declare -i i=0 k=0 slen=${#string} plen=${#pattern}

    for ((i=0; i < slen; i++)); do
	char="${string:$i:1}"
	k=i+1; next="${string:$k:1}"
	if [[ "$char" == "$prefix" ]]; then
	    if [[ "$prev" != '\' ]]; then
		k=i+1
		if [[ "${string:$k:$plen}" == "$pattern" ]]; then
		    result+="$replacement"
		    i+=plen
		    prev=""
		    continue
		fi
	    fi
	fi
	
	if ! [[ "$char" == '\' && "$next" == "$prefix" ]]; then
	    result+="$char"	    
	fi
	prev="$char"
    done
    echo "$result"
}

function §debug {

    [[ BASHRUN_DEBUG -eq 0 ]] && return
    
    # color

    local w="\033[1;37m" # white
    local r="\033[1;31m" # red
    local g="\033[1;32m" # green 
    local b="\033[1;34m" # blue
    local c="\033[1;36m" # cyan
    local m="\033[1;35m" # magenta
    local y="\033[1;33m" # yellow
    local n="\033[0m"    # none
    local d="$b"         # default
    local v="$w"         # variable

    local col=""

    # print function name
    
    local _func=${FUNCNAME[1]}
    _func=${_func//}
    _func=${_func/§/}
    
    local _from=${FUNCNAME[2]}
    _from=${_from//}
    _from=${_from:-shell}

    case $1 in	
	fail)
	    col=$r
	    shift
	    ;;
	warn)
	    col=$y
	    shift
	    ;;
	info)
	    col=$g
	    shift
	    ;;
	emph)
	    col=$c
	    shift
	    ;;
	*)
	    col=$g
	    ;;
    esac
    
    if [[ bashrun_debug_action -eq 1 ]]; then
	echo -ne "$col$_from$n $d" >&2
    else
	echo -ne "$col$_func$n $d" >&2
    fi

    local str=''
    local requested=0

    for str in "$@"; do
	
	if [[ "${str:0:1}" == "-" && "$str" != "->" ]]; then # color option
	    col="${str:1:1}"
	    echo -ne "${!col}" >&2
	    requested=1

	else
	    [[ requested -eq 0 ]] && echo -ne "$d" >&2 
	    echo -n "$str " >&2
	    requested=0
	fi
    done
    echo -e "$n" >&2
}

function §separator {

    [[ BASHRUN_DEBUG -eq 0 ]] && return

    local y="\033[1;33m" # yellow
    local b="\033[1;34m" # blue
    local n="\033[0m"    # none

    local prefix="--"
    case "$1" in
	begin)
	    prefix=">>"
	    shift
	    ;;
	end)
	    prefix="<<"
	    shift
	    ;;
    esac

    local title=$1
    local width=${2:-$COLUMNS}
    
    echo -ne "$b" >&2
    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -ne "$prefix $y$title$b " >&2
    fi
    
    local i=0;
    for (( i=1; i<=$width; i++ )); do
	echo -n "-" >&1
    done
    
    echo -e "$n" >&2
}

function §prepare_logfile {

    # set to /dev/null if empty
    if [[ "$bashrun_logfile" == "" ]]; then 
	bashrun_logfile="/dev/null"
    fi
 
    # touch unless exists
    if [[ ! -e "$bashrun_logfile" ]]; then
	§debug "creating logfile $bashrun_logfile"
	touch "$bashrun_logfile"
    fi

    # revert to /dev/null unless writable
    if [[ ! -w "$bashrun_logfile" ]]; then
	§debug "logfile $bashrun_logfile is not writeable"
	bashrun_logfile="/dev/null"
    fi
}

function §ks2kn {
    local keyseq=$1

    if §keynames.seek "$keyseq"; then
	echo $(§keyname.get_name)
	return 0
    fi

    local enter="Ret"
    local keyname=$keyseq

    keyname=${keyname/\\e/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\M-/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\\?/?}

    keyname=${keyname/C-m/$enter}
    if [[ "$keyname" =~ [a-zA-z]$enter ]]; then
	keyname=${keyname/$enter/-$enter}
    fi
    echo "$keyname"
}

function §print_line {

    local title=$1
    local char=${2:--}
    local width=${3:-$COLUMNS}
    local i;

    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -n "$char$char $title "
    fi

    for((i=0; i<$width; i++)); do
	echo -n $char
    done
    echo
}

function §print_bindings {

    local w="\033[1;37m" # white
    local r="\033[1;31m" # red
    local g="\033[1;32m" # green 
    local b="\033[1;34m" # blue
    local c="\033[1;36m" # cyan
    local m="\033[1;35m" # magenta
    local y="\033[1;33m" # yellow
    local n="\033[0m"    # none

    local mode="$(§readline.get_setting 'editing-mode')"
    local keymaps="emacs"
    local keymap id ids covered action keyname
    
    if [[ "$mode" == "vi" ]]; then
	keymaps="vi-insert vi-command"
    fi
    mode+="-mode"
    
    for keymap in $keymaps; do
	ids="$(§bindings.select keymap "$keymap")"
	[[ -z "$ids" ]] && continue

	echo -e "${w}Bashrun Keybindings$n ($c$mode$n):\n"

	covered=""

	for id in $ids; do
	    §bindings.seek "$id"
	    §binding.bound? || continue

	    action="$(§binding.get_action)"
	    if §actions.seek "$action"; then
		keyname="$(§binding.get_keyname)"
		[[ " $covered " =~ " $keyname " ]] && continue
			
		echo -en "\t$b$keyname$n\t"
		echo -en "$(§action.get_description)"
		if [[ -n "$(§action.get_depends)" ]]; then
    		    echo -en " ($(§action.print_depends))"
		fi
		echo
		covered+="$keyname "
	    fi
	done
	echo
    done	
}

function §tilde_path {
    # replace $HOME with a tilde for printing
    local path="$1"
    path=${path/$HOME/\~}
    echo "$path"
}
