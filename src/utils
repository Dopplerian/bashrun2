# -*- shell-script -*-

################################################################################

BASHRUN_DEBUG_ACTION=0

function defined? {
    [[ ${!1-X} == ${!1-Y} ]]
}

function bashrun.debug {

    # bashrun.debug [--success] "var=" var "->" g "yes!" 
    # bashrun.debug --warn "var=" var "->" y "hmm..." 
    # bashrun.debug --fail "var=" var "->" r "you fail!" 

    [[ BASHRUN_DEBUG -eq 0 ]] && return
    
    # color

    local w="\033[1;37m" # white
    local r="\033[1;31m" # red
    local g="\033[1;32m" # green 
    local b="\033[1;34m" # blue
    local c="\033[1;36m" # cyan
    local m="\033[1;35m" # magenta
    local y="\033[1;33m" # yellow
    local n="\033[0m"    # none
    local d="$b"         # default
    local v="$w"         # variable
    
    local col=""

    # print function name
    
    local _func=${FUNCNAME[1]}
    _func=${_func//}
    _func=${_func/bashrun./}
    
    local _from=${FUNCNAME[2]}
    _from=${_from//}
    _from=${_from:-shell}

    case $1 in	
	fail)
	    col=$r
	    shift
	    ;;
	warn)
	    col=$y
	    shift
	    ;;
	info)
	    col=$g
	    shift
	    ;;
	emph)
	    col=$c
	    shift
	    ;;
	*)
	    col=$g
	    ;;
    esac
    if [[ BASHRUN_DEBUG_ACTION -eq 1 ]]; then
	echo -ne "$col$_from$n $d"
    else
	echo -ne "$col$_func$n $d"
    fi

    local str=''
    local requested=0

    for str in "$@"; do
	
	if [[ "$str" =~ ^-([a-z])$ ]]; then # color
	    col="${BASH_REMATCH[1]}"
	    echo -ne "${!col}"
	    requested=1

	elif [[ ! "$str" =~ ^[0-9] && $(defined? "$str") ]]; then # variable
	    if defined? "$str"; then
		echo -ne "$d$str$b$v " # name
		echo -n  "${!str} "    #value 
	    fi
	else
	    [[ requested -eq 0 ]] && echo -ne "$d" 
	    echo -n "$str "
	    requested=0
	fi
    done
    echo -e "$n"
}

function bashrun.separator {

    [[ BASHRUN_DEBUG -eq 0 ]] && return

    local y="\033[1;33m" # yellow
    local b="\033[1;34m" # blue
    local n="\033[0m"    # none
    local title=$1
    local width=${2:-$COLUMNS}

    
    echo -ne "$b"
    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -ne "-- $y$title$b "
    fi
    
    local i=0;
    for (( i=1; i<=$width; i++ )); do
	echo -n "-"
    done
    
    echo -ne "$n"
    echo
}

function bashrun.edit_mode {     
    
    local state=${1:-1}

    objects.focus "action"

    if [[ state -eq 1 ]]; then

	OLDPS1="$PS1";
	PS1='\[\033[1;34m\]<\[\033[1;33m\]$(objects.focus)\[\033[1;34m\]:\[\033[1;37m\] $(+$(objects.focus) --name)\[\033[1;34m\]> \[\033[0m\]';
	
	function ls () 
	{ 
            $(objects.focus)s.list "$@"
	};
	complete -F objects.complete_id ls
	
	function cd ()
	{
	    if [[ "$#" == "0" ]]; then
		+action
		return
	    fi
	    
	    if type -t +$1 &> /dev/null; then
		+$1
	    fi
	}
	complete -F objects.complete_type cd

	BASHRUN_EDIT_MODE=1
	actions.seek_start

	xdotool key --clearmodifiers ctrl+m;
	return 1
    else
	
	PS1="$OLDPS1";
	unset -f ls;
	complete -o filenames -F _longopt ls
	
	unset -f cd
	complete -o filenames -o nospace -F _cd cd
	
	BASHRUN_EDIT_MODE=0
	
	xdotool key --clearmodifiers ctrl+m;
	# RELEASE: wait for xdotool upgrade
    fi
}

function bashrun.prepare_directories {

    # create XDG directories
    local dir
    for dir in 'CONFIG' 'DATA' 'CACHE'; do

	dir="BASHRUN_${dir}_HOME"
	dir=${!dir}
	
	if [[ ! -d $dir ]]; then
	    bashrun.debug "$dir"
	    install -d -m 700 $dir
	fi
    done
}

function bashrun.prepare_logfile {

    # set to /dev/null if empty
    if [[ "$BASHRUN_LOGFILE" == "" ]]; then 
	BASHRUN_LOGFILE="/dev/null"
    fi
 
    # touch unless exists
    if [[ ! -e "$BASHRUN_LOGFILE" ]]; then
	bashrun.debug "creating logfile $BASHRUN_LOGFILE"
	touch "$BASHRUN_LOGFILE"
    fi

    # revert to /dev/null unless writable
    if [[ ! -w "$BASHRUN_LOGFILE" ]]; then
	bashrun.debug "logfile $BASHRUN_LOGFILE is not writeable"
	BASHRUN_LOGFILE="/dev/null"
    fi
}

function function? {
    [[ "$(type -t $1 2> /dev/null)" == "function" ]]
    return $?
}

function ks2kn {
    local keyseq=$1

    if keynames.seek "$keyseq"; then
	echo $(keyname.get_name)
	return 0
    fi

    local enter="Ret"
    local keyname=$keyseq

    keyname=${keyname/\\e/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\M-/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\\?/?}

    keyname=${keyname/C-m/$enter}
    if [[ "$keyname" =~ [a-zA-z]$enter ]]; then
	keyname=${keyname/$enter/-$enter}
    fi
    echo "$keyname"
}

function print_line {

    local title=$1
    local char=${2:--}
    local width=${3:-$COLUMNS}
    local i;

    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -n "$char$char $title "
    fi

    for((i=0; i<$width; i++)); do
	echo -n $char
    done
    echo
}

function print_header {
    
    local title="$1"

    # remove the namespace prefix
    local prefix="$(echo $_OBJECTS_NAMESPACE | tr "[:lower:]" "[:upper:]")"
    title=${title/${prefix}_/}

    local char=${2:-#}
    print_line '' "$char"
    print_line "$title" "$char" '-1'
    print_line '' "$char"
    echo
}

function display_message {
    
    local msg="$1"
    echo -ne "$msg"
    sleep 3
    echo
}

