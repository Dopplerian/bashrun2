# -*- shell-script -*-

################################################################################

BASHRUN_DEBUG_ACTION=0

function §bash3 {
    [[ ${BASH_VERSINFO[0]} -eq 3 ]]
}

function §bash4 {
    [[ ${BASH_VERSINFO[0]} -eq 4 ]]
}

function §defined? {
    [[ "${!1-X}" == "${!1-Y}" ]]
}

function §function.defined? {
    [[ "$(type -t $1 2> /dev/null)" == "function" ]]
    return $?
}

function §function.exported? () {
    [[ "$(declare -pf | grep foo)" =~ "declare -fx $1" ]]
}	

function §function.code {
    echo "$(type $1 | sed '1 d')"
}

function §function.clone {

    local function="$1"
    local newname="$2"

    if $(type -t $function &> /dev/null); then
	local code="$(echo -n '#'; type $function)"
	code="${code/$function \(\)/$newname ()}"
	eval "$code"
    else
	echo "§function.clone: error: no such function: $function"
    fi
}

BASHRUN_XDOTOOL="unknown"

function §xdo {

    if [[ "$BASHRUN_XDOTOOL" == "unknown" ]]; then

        # assume xdotool is present
	BASHRUN_XDOTOOL=1

        # check if xdotool available at all
	if ! which xdotool &>/dev/null; then
	    BASHRUN_XDOTOOL=0

        # check if >=20090815 (support for set_window)
	elif (xdotool set_window 2>&1 | grep 'Unknown command' &>/dev/null); then
	    BASHRUN_XDOTOOL=0
	fi
    fi
    
    if [[ BASHRUN_XDOTOOL -eq 0 ]]; then
	§display_message "Error" \
	    "Bashrun requires xdotool>=20090815\n\nSee http://www.semicomplete.com/projects/xdotool/\n\nExiting..."
	exit 1
    fi

    if [[ BASHRUN_DEBUG -eq 1 ]]; then
	xdotool $@
    else
	xdotool $@ 2>/dev/null
    fi
}
export -f §xdo

function §debug {

    # §debug [--success] "var=" var "->" g "yes!" 
    # §debug --warn "var=" var "->" y "hmm..." 
    # §debug --fail "var=" var "->" r "you fail!" 

    [[ BASHRUN_DEBUG -eq 0 ]] && return
    
    # color

    local w="\033[1;37m" # white
    local r="\033[1;31m" # red
    local g="\033[1;32m" # green 
    local b="\033[1;34m" # blue
    local c="\033[1;36m" # cyan
    local m="\033[1;35m" # magenta
    local y="\033[1;33m" # yellow
    local n="\033[0m"    # none
    local d="$b"         # default
    local v="$w"         # variable
    
    local col=""

    # print function name
    
    local _func=${FUNCNAME[1]}
    _func=${_func//}
    _func=${_func/§/}
    
    local _from=${FUNCNAME[2]}
    _from=${_from//}
    _from=${_from:-shell}

    case $1 in	
	fail)
	    col=$r
	    shift
	    ;;
	warn)
	    col=$y
	    shift
	    ;;
	info)
	    col=$g
	    shift
	    ;;
	emph)
	    col=$c
	    shift
	    ;;
	*)
	    col=$g
	    ;;
    esac
    if [[ BASHRUN_DEBUG_ACTION -eq 1 ]]; then
	echo -ne "$col$_from$n $d"
    else
	echo -ne "$col$_func$n $d"
    fi

    local str=''
    local requested=0

    for str in "$@"; do
	
	if [[ "$str" =~ ^-([a-z])$ ]]; then # color
	    col="${BASH_REMATCH[1]}"
	    echo -ne "${!col}"
	    requested=1

	elif [[ ! "$str" =~ ^[0-9] && $(§defined? "$str") ]]; then # variable
	    if §defined? "$str"; then
		echo -ne "$d$str$b$v " # name
		echo -n  "${!str} "    #value 
	    fi
	else
	    [[ requested -eq 0 ]] && echo -ne "$d" 
	    echo -n "$str "
	    requested=0
	fi
    done
    echo -e "$n"
}

function §separator {

    [[ BASHRUN_DEBUG -eq 0 ]] && return

    local y="\033[1;33m" # yellow
    local b="\033[1;34m" # blue
    local n="\033[0m"    # none
    local title=$1
    local width=${2:-$COLUMNS}

    
    echo -ne "$b"
    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -ne "-- $y$title$b "
    fi
    
    local i=0;
    for (( i=1; i<=$width; i++ )); do
	echo -n "-"
    done
    
    echo -ne "$n"
    echo
}

function §prepare_directories {

    # create XDG directories
    local dir
    for dir in 'CONFIG' 'DATA' 'CACHE'; do

	dir="BASHRUN_${dir}_HOME"
	dir=${!dir}
	
	if [[ ! -d $dir ]]; then
	    §debug "$dir"
	    install -d -m 700 $dir
	fi
    done
}

function §prepare_logfile {

    # set to /dev/null if empty
    if [[ "$BASHRUN_LOGFILE" == "" ]]; then 
	BASHRUN_LOGFILE="/dev/null"
    fi
 
    # touch unless exists
    if [[ ! -e "$BASHRUN_LOGFILE" ]]; then
	§debug "creating logfile $BASHRUN_LOGFILE"
	touch "$BASHRUN_LOGFILE"
    fi

    # revert to /dev/null unless writable
    if [[ ! -w "$BASHRUN_LOGFILE" ]]; then
	§debug "logfile $BASHRUN_LOGFILE is not writeable"
	BASHRUN_LOGFILE="/dev/null"
    fi
}

function §ks2kn {
    local keyseq=$1

    if §keynames.seek "$keyseq"; then
	echo $(§keyname.get_name)
	return 0
    fi

    local enter="Ret"
    local keyname=$keyseq

    keyname=${keyname/\\e/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\M-/M-}
    keyname=${keyname/\\C-/C-}
    keyname=${keyname/\\\?/?}

    keyname=${keyname/C-m/$enter}
    if [[ "$keyname" =~ [a-zA-z]$enter ]]; then
	keyname=${keyname/$enter/-$enter}
    fi
    echo "$keyname"
}

function §print_line {

    local title=$1
    local char=${2:--}
    local width=${3:-$COLUMNS}
    local i;

    if [[ "$title" != '' ]]; then
	(( width = width - ${#title} - 4 )) 
	echo -n "$char$char $title "
    fi

    for((i=0; i<$width; i++)); do
	echo -n $char
    done
    echo
}

function §print_header {
    
    local title="$1"

    # remove the namespace prefix
    local prefix="$(echo $_OBJECTS_NAMESPACE | tr "[:lower:]" "[:upper:]")"
    title=${title/${prefix}_/}

    local char=${2:-#}
    §print_line '' "$char"
    §print_line "$title" "$char" '-1'
    §print_line '' "$char"
    echo
}

function §print_bindings {
        
    # some colours (used in §print_bindings)
    local w="\033[1;37m" # white
    local r="\033[1;31m" # red
    local g="\033[1;32m" # green 
    local b="\033[1;34m" # blue
    local c="\033[1;36m" # cyan
    local m="\033[1;35m" # magenta
    local y="\033[1;33m" # yellow
    local n="\033[0m"    # none

    # display order of core actions, | denotes a newline
    local order="bashrun-bindings bashrun-manual debug | 
                 pass abort quit |
                 run term-run term-page term-hold | 
                 su-run su-term-run su-term-page su-term-hold |
                 show-manual show-info show-help |
                 browse google-search dict-lookup |
                 cycle-size cycle-mode"
        
    local id=""
    local bindings=""
    local keymap=""

    for keymap in emacs vi-insert vi-command; do
	bindings="$(§bound_and_sorted $keymap)"
	if [[ -n "$bindings" ]]; then
	    echo -e "${c}$keymap:${n}\n"
	    for id in $bindings; do
		if [[ "$id" == "|" ]]; then		    
		    echo
		else
		    §print_binding "$id"
		fi
	    done
	    echo
	fi
    done
}

function §bound_and_sorted {
    
    local keymap="${1:-emacs}"
    local ids="$(§bindings.select keymap "$keymap")"

    local sorted=""
    local action=""
    local id=""
    local len=0
    local found=0

    # core actions
    for action in $order; do
	if [[ "$action" != '|' ]]; then
	    for id in $ids; do
		§bindings.seek "$id"
		if [[ "$(§binding.get_action)" == "$action" &&
			    "$(§binding.get_is_bound)" == "1" ]]; then
		    sorted="$sorted $id"
		    found=1
		fi
	    done
	else
	    len=${#sorted}
	    [[ ${sorted:$len-1:1} != '|' ]] && sorted="$sorted |"
	fi
    done
    
    # user actions
    local first=1

    for id in $ids; do
	§bindings.seek "$id"
	§actions.seek "$(§binding.get_action)"
	if [[ "$(§action.get_core)" != "1" && "$(§binding.get_is_bound)" == "1" ]]; then	    
	    found=1
	    if [[ "$first" == "1" ]]; then
		sorted="$sorted | $id"
		first=0
	    else
		sorted="$sorted $id"
	    fi
	fi
    done
    [[ found -eq 1 ]] && echo "$sorted"
}

function §print_binding {
    
    local id="$1"
    local name=""
    local desc=""
    local deps=""
    local keyname=""
    local keyseq=""

    §bindings.seek "$id"

    name="$(§binding.get_action)"
    
    §actions.seek "$name"
    desc="$(§action.get_desc)"
    
    deps="$(§action.pretty_print_deps)"
    keyseq="$(§binding.get_keyseq)"
    
    if §keynames.seek "$keyseq"; then
	keyname="$(§keyname.get_name)"
    else
	keyname="$(§ks2kn $keyseq)"
    fi
    
    echo -ne " ${w}$keyname\t${n}$desc"
    if [[ "$deps" != "" ]]; then
	echo -e " (requires $deps${n})"
    else
	echo
    fi
}

function §display_message {

    local title="$1"
    local text="$2"

    if (which dialog &>/dev/null && which xdotool &>/dev/null && §window.terminal?) then
	local prev_size="$(§window.size)"
	§window.size --hint 40 12
	
	dialog --no-shadow --title "Bashrun $title" --msgbox "\n$text" 12 40
	
	§window.size --hint $prev_size
	tput reset

    elif which zenity &>/dev/null; then
	local type="--info"
	[[ "$title" =~ rror ]] && type="--error"
	[[ "$title" =~ arning ]] && type="--warning"
	    
	zenity $type --title "Bashrun $title" --text "$text" &>/dev/null
    
    elif which kdialog &>/dev/null; then
	local type="--msgbox"
	[[ "$title" =~ rror ]] && type="--error"
	[[ "$title" =~ arning ]] && type="--sorry"

	kdialog --title "Bashrun $title" $type "$text" &>/dev/null
	
    elif which xmessage &>/dev/null; then
	xmessage "$title: $text" &>/dev/null
    else
	local saved="$(§terminal.get_name)"
	§terminals.seek "default"
	eval "$(§terminal.get_command) 'echo -e \"Bashrun $title:\n\n$text\n\" | less' &>/dev/null"
	§terminals.seek "$saved"
    fi
}

