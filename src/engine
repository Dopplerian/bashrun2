# -*- shell-script -*-

################################################################################

BASHRUN_ACTION=''
BASHRUN_EXECMODE=''
BASHRUN_ENGINE_BUSY=0

BASHRUN_LOGFILE=$BASHRUN_CACHE_HOME/log
BASHRUN_PIDFILE=$BASHRUN_CACHE_HOME/pids
BASHRUN_PONGFILE=$BASHRUN_CACHE_HOME/pong

function bashrun_engine_init {
    
    bashrun_log "initializing..."

    # shutdown on exit
    trap bashrun_engine_shutdown EXIT

    # append pid to shared pidfile
    echo $$ >> $BASHRUN_PIDFILE

    # setup
    bashrun_prepare_directories

    # get current readline bindings
    readline_get_bindings
    
    # source rc file
    source /home/chenno/workspace/bashrun/src/rc

    # escape from trap in interactive mode
    PROMPT_COMMAND="trap DEBUG; $PROMPT_COMMAND"

    # enable extended debugging features
    shopt -s extdebug

    # init exec mode
    BASHRUN_EXECMODE='&'
}

function bashrun_engine_action {

    local action=$1       # action to perform
    local type=$2         # action type override
    local command="$3"    # command override

    if actions_seek $action; then

	# wait until engine is ready
	while bashrun_engine_busy?; do
	    sleep 0.25
	done

	bashrun_engine_busy 1

	BASHRUN_ACTION=$action

	# type override
	[[ $type == '' ]] && type=$(action_type)

	bashrun_log "$action ($type)"

	# dispatch action according to type
	case $type in
	    
	    trap-and-launch)
	        # set the trap
		bashrun_log "trap is set"
		trap bashrun_engine_trap DEBUG
		;; 
	    
	    launch)
		# command override
		[[ $command == '' ]] && command=':'
     
		# run action directly
		bashrun_engine_launch "$command"
		;;
	    
	    shell)
		# just run action here
		if action_function?; then
		    action_run_function
		fi
		bashrun_engine_busy 0
		;;
	    *)
		bashrun_log "no such action type: $type"
		;;
	esac
    else
	bashrun_log "no such action: $action"
    fi
}

function bashrun_engine_trap {
    
    # the verbatim command line entered
    BASHRUN_COMMAND_LINE=$(bashrun_command_get_line)

    # the command about to be executed,
    # as expanded by the shell
    BASHRUN_COMMAND="$BASH_COMMAND"
    
    # assume execmode background
    BASHRUN_EXECMODE="&"

    # remove quotes (;|&)
    bashrun_command_unquote
    
    # pass through trap builtin
    if [[ "$BASHRUN_COMMAND" =~ ^trap ]]; then
	bashrun_log "trap is removed"
	bashrun_engine_busy 0
	return 0
    fi
    bashrun_log "$BASHRUN_COMMAND"

    bashrun_engine_launch
    return 1
}

function bashrun_engine_launch {

    local command=$1

    # command override
    if [[ $command != '' ]]; then
	BASHRUN_COMMAND="$command"
	BASHRUN_COMMAND_LINE="$command"
    fi

    if actions_seek $BASHRUN_ACTION; then
	if action_function?; then
	    if ! action_run_function; then
		bashrun_engine_busy 0
		return 0
	    fi
	fi
    fi

    bashrun_log "$BASHRUN_COMMAND"
    
    if bashrun_command_word_is_executable?; then
	bashrun_engine_execute
    else
	bashrun_log "not executable."
    fi

    bashrun_engine_busy 0
}

function bashrun_engine_execute {

    bashrun_prepare_logfile

    # execute command
    if [[ "$BASHRUN_EXECMODE" == "&" ]]; then
	/bin/bash -c "$BASHRUN_COMMAND >> $BASHRUN_LOGFILE 2>&1 &" > /dev/null 2>&1
    else
	# this can only be a su command (so far)
	/bin/bash -c "$BASHRUN_COMMAND"
    fi
}

function bashrun_engine_busy {
    BASHRUN_ENGINE_BUSY=$1
}

function bashrun_engine_busy? {
    [[ "$BASHRUN_ENGINE_BUSY" == "1" ]]
    return $?
}

function bashrun_engine_shutdown { 

    # remove this pid from the pidfile
    local pid=''
    echo -n '' > $BASHRUN_PIDFILE.tmp

    for pid in $(cat $BASHRUN_PIDFILE); do
	if [[ "$pid" != "$$" ]]; then
	    echo $pid > $BASHRUN_PIDFILE.tmp
	fi
    done
    mv $BASHRUN_PIDFILE.tmp $BASHRUN_PIDFILE

    # remove untrap from prompt command
    PROMPT_COMMAND=${PROMPT_COMMAND/trap DEBUG\;/}

    # disable extended debugging features
    shopt -u extdebug

    bashrun_remote_cleanup    

    bashrun_log "exit"
}    
