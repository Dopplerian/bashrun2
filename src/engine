# -*- shell-script -*-

################################################################################

BASHRUN_ACTION=''
BASHRUN_EXECMODE=''
BASHRUN_ENGINE_BUSY=0

BASHRUN_RCFILE=$BASHRUN_CONFIG_HOME/rc

BASHRUN_TIMESTAMP=$BASHRUN_CACHE_HOME/timestamp

BASHRUN_LOGFILE=/dev/null
BASHRUN_PIDFILE=$BASHRUN_CACHE_HOME/pid
BASHRUN_WIDFILE=$BASHRUN_CACHE_HOME/wid

function bashrun.engine.init {
    
    bashrun.separator "bashrun-engine $BASHRUN_VERSION"

    # write pid and wid if this is the first instance
    if [ ! -f $BASHRUN_PIDFILE ]; then
	bashrun.debug "pid" -v "$$" '>' -v "${BASHRUN_PIDFILE/$HOME/~}"
	echo $$ > $BASHRUN_PIDFILE
    fi

    if [ ! -f $BASHRUN_WIDFILE ]; then
	bashrun.debug "wid" -v "$WINDOWID" '>' -v "${BASHRUN_WIDFILE/$HOME/~}"
	echo $WINDOWID > $BASHRUN_WIDFILE
    fi

    # set wid to terminal $WINDOWID here
    bashrun.window.id $WINDOWID

    # get current readline bindings
    bashrun.debug "getting current readline bindings..."
    readline_get_bindings
        
    # source rcfile if modified, else restore dumped state
    local rcfile="${BASHRUN_RCFILE/$HOME/~}"

    if [[ "$BASHRUN_RCFILE" -nt "$BASHRUN_TIMESTAMP" ]]; then

	bashrun.debug -v "rcfile" -c "modified"
	bashrun.separator "source $rcfile"

	bashrun.debug "installing default actions..."
	source $BASHRUN_SHARE/defaults

	source $BASHRUN_RCFILE
	touch $BASHRUN_TIMESTAMP

	bashrun.debug "dumping current config state..."
	objects.dump

	bashrun.separator
    else
	bashrun.debug warn -v "$rcfile" -y "not modified"
	bashrun.debug warn "restoring cached config state..."
	objects.restore
    fi

    # run init callbacks
    bashrun.debug -v "+action" -v "--init" "callbacks..."
    actions.init

    # reset object positions
    objects.seek_start

    # enable extended debugging features
    shopt -s extdebug

    # prepare escape from trap
    PROMPT_COMMAND="trap DEBUG; $PROMPT_COMMAND"

    # init exec mode
    BASHRUN_EXECMODE='&'

    # shutdown on exit
    trap bashrun.engine.shutdown EXIT
    
    bashrun.debug emph -y "done"
    bashrun.separator 
}

function bashrun.engine.action {

    local action=$1       # action to perform
    local type=$2         # action type override
    local command="$3"    # command override

    bashrun.separator "engine $action"

    if actions.seek $action; then

	# wait until engine is ready
	while bashrun.engine.busy?; do
	    sleep 0.25
	done

	bashrun.engine.busy 1

	BASHRUN_ACTION=$action

	# type override
	[[ $type == '' ]] && type=$(action.get_type)

	bashrun.debug -v "$action" -c "$type"

	# dispatch action according to type
	case $type in
	    
	    trap-and-launch)
	        # set the trap
		bashrun.debug -v "trap" -c "set"
		trap bashrun.engine.trap DEBUG
		;; 
	    
	    launch)
		# command override
		[[ $command == '' ]] && command=':'
     
		# run action directly
		bashrun.engine.launch "$command"
		;;
	    
	    shell)
		# just run action here
		if action.function?; then
		    action.run $command
		    bashrun.separator
		fi
		bashrun.engine.busy 0
		;;
	    *)
		bashrun.debug fail "no such action type:" -v "$type"
		;;
	esac
    else
	bashrun.debug fail "no such action:" -v "$action"
    fi
}

function bashrun.engine.trap {
    
    # the verbatim command line entered
    BASHRUN_COMMAND_LINE=$(bashrun.command.get_line)

    # the command about to be executed,
    # as expanded by the shell
    BASHRUN_COMMAND="$BASH_COMMAND"
    
    # assume execmode background
    BASHRUN_EXECMODE="&"

    # remove quotes (;|&)
    bashrun.command.unquote
    
    # pass through trap builtin
    if [[ "$BASHRUN_COMMAND" =~ ^trap ]]; then
	bashrun.debug -v "trap" -c "removed"
	bashrun.separator 
	bashrun.engine.busy 0
	return 0
    fi
    bashrun.debug "command:" -v "$BASHRUN_COMMAND"
    bashrun.debug "   line:" -v "$BASHRUN_COMMAND_LINE"

    bashrun.engine.launch

    bashrun.separator 

    return 1
}

function bashrun.engine.launch {

    local command=$1

    # command override
    if [[ $command != '' ]]; then
	BASHRUN_COMMAND="$command"
	BASHRUN_COMMAND_LINE="$command"
    fi

    if actions.seek $BASHRUN_ACTION; then
	if action.function?; then
	    if ! action.run; then
		BASHRUN_RULES_APPLIED=0
		bashrun.engine.busy 0
		bashrun.separator
		return 0
	    fi
	fi
    fi

    bashrun.debug "$BASHRUN_COMMAND"
    
    if bashrun.command.executable?; then
	bashrun.engine.execute
    else
	bashrun.debug fail "not executable."
    fi

    BASHRUN_RULES_APPLIED=0
    bashrun.engine.busy 0
    return 0
}

function bashrun.engine.execute {

    bashrun.prepare_logfile

    # execute command
    if [[ "$BASHRUN_EXECMODE" == "&" ]]; then
	/bin/bash -c "$BASHRUN_COMMAND >> $BASHRUN_LOGFILE 2>&1 &" > /dev/null 2>&1
    else
	# this can only be a su command (so far)
	/bin/bash -c "$BASHRUN_COMMAND"
    fi
}

function bashrun.engine.busy {
    BASHRUN_ENGINE_BUSY=$1
}

function bashrun.engine.busy? {
    [[ "$BASHRUN_ENGINE_BUSY" == "1" ]]
    return $?
}

function bashrun.engine.save {

    local f=${1:-$BASHRUN_RCFILE}

    bashrun.debug "saving to" -v $f

    echo "# -*- shell-script -*-" > $f
    echo "# BASHRUN CONFIG VERSION $BASHRUN_VERSION" >> $f
    echo >> $f

    modes.code >> $f
    rules.code >> $f
    handlers.code >> $f
    bookmarks.code >> $f
    actions.code >> $f

    if [[ "$f" == "$BASHRUN_RCFILE" ]]; then
	touch $BASHRUN_TIMESTAMP
    fi

    objects.dump

    objects.seek_start
}

function +save {
    bashrun.engine.save "$1"
}

function bashrun.engine.shutdown { 

    # run shutdown callbacks
    actions.shutdown

    [ -f $BASHRUN_PIDFILE ] && rm $BASHRUN_PIDFILE
    [ -f $BASHRUN_WIDFILE ] && rm $BASHRUN_WIDFILE

    # remove untrap from prompt command
    PROMPT_COMMAND=${PROMPT_COMMAND/trap DEBUG\;/}

    # disable extended debugging features
    shopt -u extdebug

    bashrun.remote.cleanup    

    bashrun.debug "exit"
}    
