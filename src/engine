# -*- shell-script -*-

################################################################################

BASHRUN_ACTION=''
BASHRUN_EXECMODE=''
BASHRUN_ENGINE_BUSY=0
BASHRUN_LOGFILE=${BASHRUN_LOGFILE:-/dev/null}
BASHRUN_CMD_NOT_FOUND_HANDLE=0

function §engine.init {
    
    §engine.busy

    §separator "bashrun $BASHRUN_VERSION"

    §progress.update +10 "Initializing... [window]"

    # set wid to terminal $WINDOWID
    §window.id $WINDOWID

    # get current readline bindings
    §debug "getting current readline settings and bindings..."
    §readline.get_settings
    §readline.get_bindings

    # init keymap
    BASHRUN_KEYMAP="$(§readline.get_setting keymap)"
    §debug "initial keymap set to" -v $BASHRUN_KEYMAP

    §progress.update +1
        
    # load/restore configuration
    §configs.restore

    # create completion functions for handlers
    §handlers.install_completion

    # reset object positions
    §objects.seek_start

    §progress.update 100 "Initializing... [engine]"

    # initialize mode passed from env
    §modes.seek "$BASHRUN_MODE"
    §debug "calling" -v "§mode.init" "for" -v "$(§mode.get_name)"
    §mode.init

    # enable extdebug and prepare escape from trap
    # (bashdb bugs out if extdebug is set directly from a startup file)
    PROMPT_COMMAND="trap DEBUG; shopt -s extdebug;$PROMPT_COMMAND"

    # init exec mode
    BASHRUN_EXECMODE='&'

    # install command_not_found_handle for bash>=4 -> handle
    if §bash4; then
	function command_not_found_handle {
	    if [[ BASHRUN_CMD_NOT_FOUND_HANDLE -eq 1 ]]; then
		if §engine.idle?; then
		    BASHRUN_FROM_CMDNFH=1 §engine.action run 0 "$*"
		fi
	    fi
	}
    fi

    # shutdown on EXIT and TERM
    trap §engine.shutdown TERM
    trap §engine.shutdown EXIT
    trap §remote.run SIGUSR1

    §debug emph -y "done"

    §separator 
    
    §progress.reset

    touch $BASHRUN_CACHE_HOME/${BASHRUN_MODE}-ready

    §engine.idle
}

function §engine.action {

    local action=$1       # action to perform
    local input=$2        # input override
    local command="$3"    # command override

    §separator "engine $action $command"

    if §actions.seek $action; then

	§engine.busy
	BASHRUN_RULES_APPLIED=0

	BASHRUN_ACTION=$action

	# overrides
	[[ -z "$input" ]] && input=$(§action.get_input)
	
	§debug "action" -v "$action" "input" -c "$input"

	case $input in
	    
	    1)
	        # accept input via trap
		§debug "accepting input from" -c "DEBUG trap"
		trap §engine.trap DEBUG
		;; 
	    
	    0)
		# launch directly 
		§engine.launch "$command"
		;;	    
	esac
    else
	§debug fail "no such action:" -v "$action"
    fi
}

function §engine.trap {
    
    # the verbatim command line entered
    BASHRUN_COMMAND_LINE=$(§command.get_line)

    # the command about to be executed,
    # as expanded by the shell
    BASHRUN_COMMAND="$BASH_COMMAND"
    
    # assume execmode background
    BASHRUN_EXECMODE="&"

    # remove quotes (;|&)
    §command.unquote

    # pass through trap builtin
    if [[ "$BASHRUN_COMMAND" =~ ^trap ]]; then
	§debug -v "trap" -c "removed"
	§engine.busy? && §engine.reset 
	return 0
    fi

    # pass through exit builtin
    [[ "$BASHRUN_COMMAND" =~ ^exit ]] && return 0

    §debug "line   :" -v "$BASHRUN_COMMAND_LINE"
    §debug "command:" -v "$BASHRUN_COMMAND"

    §engine.launch

    return 1
}

function §engine.launch {

    local command="$1"
    local status=0

    # command override
    if [[ "$command" != '' ]]; then
	§debug -c override -v "$command"
	BASHRUN_COMMAND="$command"
	BASHRUN_COMMAND_LINE="$command"
    fi
    
    if §actions.seek "$BASHRUN_ACTION"; then

	if ! §action.available?; then
	    §engine.reset 0
	    return 0
	fi
	
	if §action.function?; then
	    §action.run
	    status=$?
	    if [[ status -ne 0 ]]; then
		[[ status -eq 1 ]] && §engine.reset 
		[[ status -eq 2 ]] && §engine.reset 0
		return 0
	    fi
	fi
    fi
    §debug "$BASHRUN_COMMAND"
    
    §engine.execute
    §engine.reset
    return 0
}

function §engine.execute {

    §prepare_logfile

    # execute command
    if [[ "$BASHRUN_EXECMODE" == "&" ]]; then
	/bin/bash -c "$BASHRUN_COMMAND >> $BASHRUN_LOGFILE 2>&1 &" > /dev/null 2>&1
    else
	# this can only be a su command...        
        # map window for password entry
	§window.map && tput cr
	
	/bin/bash -c "$BASHRUN_COMMAND"

	§mode.unmap? && §window.unmap
    fi
}

function §engine.reset {

    local unmap=${1:-1}

    # reset rules
    BASHRUN_RULES_APPLIED=0

    # reset terminal
    §terminals.seek default
    
    # disable action api here to allow nested actions
    §action.api.disable 

    # unmap the window if requested/necessary
    if [[ unmap -eq 1 ]]; then 
	if §mode.unmap?; then
	    if [[ -f "$BASHRUN_RESET_TERM" ]]; then
		rm $BASHRUN_RESET_TERM
	    else
		§window.unmap
	    fi
	fi
    fi
    §engine.idle

    §debug -c "reset"

    §separator
}

function §engine.busy {
    BASHRUN_ENGINE_BUSY=1
}

function §engine.busy? {
    [[ "$BASHRUN_ENGINE_BUSY" == "1" ]]
}

function §engine.idle {
    BASHRUN_ENGINE_BUSY=0
}

function §engine.idle? {
    [[ "$BASHRUN_ENGINE_BUSY" == "0" ]]
}

function §engine.shutdown { 

    # remove this instance from registry
    §registry.remove

    rm $BASHRUN_CACHE_HOME/${BASHRUN_MODE}-ready

    §debug "exit"
    exit 0
}    
